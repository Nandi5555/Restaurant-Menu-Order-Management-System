"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iceberg-js";
exports.ids = ["vendor-chunks/iceberg-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/iceberg-js/dist/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/iceberg-js/dist/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IcebergError: () => (/* binding */ IcebergError),\n/* harmony export */   IcebergRestCatalog: () => (/* binding */ IcebergRestCatalog),\n/* harmony export */   getCurrentSchema: () => (/* binding */ getCurrentSchema),\n/* harmony export */   isDecimalType: () => (/* binding */ isDecimalType),\n/* harmony export */   isFixedType: () => (/* binding */ isFixedType),\n/* harmony export */   parseDecimalType: () => (/* binding */ parseDecimalType),\n/* harmony export */   parseFixedType: () => (/* binding */ parseFixedType),\n/* harmony export */   typesEqual: () => (/* binding */ typesEqual)\n/* harmony export */ });\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n    constructor(message, opts){\n        super(message);\n        this.name = \"IcebergError\";\n        this.status = opts.status;\n        this.icebergType = opts.icebergType;\n        this.icebergCode = opts.icebergCode;\n        this.details = opts.details;\n        this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [\n            500,\n            502,\n            504\n        ].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\n    }\n    /**\n   * Returns true if the error is a 404 Not Found error.\n   */ isNotFound() {\n        return this.status === 404;\n    }\n    /**\n   * Returns true if the error is a 409 Conflict error.\n   */ isConflict() {\n        return this.status === 409;\n    }\n    /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */ isAuthenticationTimeout() {\n        return this.status === 419;\n    }\n};\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n    const url = new URL(path, baseUrl);\n    if (query) {\n        for (const [key, value] of Object.entries(query)){\n            if (value !== void 0) {\n                url.searchParams.set(key, value);\n            }\n        }\n    }\n    return url.toString();\n}\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n    if (!auth || auth.type === \"none\") {\n        return {};\n    }\n    if (auth.type === \"bearer\") {\n        return {\n            Authorization: `Bearer ${auth.token}`\n        };\n    }\n    if (auth.type === \"header\") {\n        return {\n            [auth.name]: auth.value\n        };\n    }\n    if (auth.type === \"custom\") {\n        return await auth.getHeaders();\n    }\n    return {};\n}\nfunction createFetchClient(options) {\n    const fetchFn = options.fetchImpl ?? globalThis.fetch;\n    return {\n        async request ({ method, path, query, body, headers }) {\n            const url = buildUrl(options.baseUrl, path, query);\n            const authHeaders = await buildAuthHeaders(options.auth);\n            const res = await fetchFn(url, {\n                method,\n                headers: {\n                    ...body ? {\n                        \"Content-Type\": \"application/json\"\n                    } : {},\n                    ...authHeaders,\n                    ...headers\n                },\n                body: body ? JSON.stringify(body) : void 0\n            });\n            const text = await res.text();\n            const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n            const data = isJson && text ? JSON.parse(text) : text;\n            if (!res.ok) {\n                const errBody = isJson ? data : void 0;\n                const errorDetail = errBody?.error;\n                throw new IcebergError(errorDetail?.message ?? `Request failed with status ${res.status}`, {\n                    status: res.status,\n                    icebergType: errorDetail?.type,\n                    icebergCode: errorDetail?.code,\n                    details: errBody\n                });\n            }\n            return {\n                status: res.status,\n                headers: res.headers,\n                data\n            };\n        }\n    };\n}\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar NamespaceOperations = class {\n    constructor(client, prefix = \"\"){\n        this.client = client;\n        this.prefix = prefix;\n    }\n    async listNamespaces(parent) {\n        const query = parent ? {\n            parent: namespaceToPath(parent.namespace)\n        } : void 0;\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces`,\n            query\n        });\n        return response.data.namespaces.map((ns)=>({\n                namespace: ns\n            }));\n    }\n    async createNamespace(id, metadata) {\n        const request = {\n            namespace: id.namespace,\n            properties: metadata?.properties\n        };\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces`,\n            body: request\n        });\n        return response.data;\n    }\n    async dropNamespace(id) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n    }\n    async loadNamespaceMetadata(id) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n        return {\n            properties: response.data.properties\n        };\n    }\n    async namespaceExists(id) {\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createNamespaceIfNotExists(id, metadata) {\n        try {\n            return await this.createNamespace(id, metadata);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return;\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar TableOperations = class {\n    constructor(client, prefix = \"\", accessDelegation){\n        this.client = client;\n        this.prefix = prefix;\n        this.accessDelegation = accessDelegation;\n    }\n    async listTables(namespace) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\n        });\n        return response.data.identifiers;\n    }\n    async createTable(namespace, request) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\n            body: request,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async updateTable(id, request) {\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            body: request\n        });\n        return {\n            \"metadata-location\": response.data[\"metadata-location\"],\n            metadata: response.data.metadata\n        };\n    }\n    async dropTable(id, options) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            query: {\n                purgeRequested: String(options?.purge ?? false)\n            }\n        });\n    }\n    async loadTable(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async tableExists(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n                headers\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createTableIfNotExists(namespace, request) {\n        try {\n            return await this.createTable(namespace, request);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return await this.loadTable({\n                    namespace: namespace.namespace,\n                    name: request.name\n                });\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n    /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */ constructor(options){\n        let prefix = \"v1\";\n        if (options.catalogName) {\n            prefix += `/${options.catalogName}`;\n        }\n        const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\n        this.client = createFetchClient({\n            baseUrl,\n            auth: options.auth,\n            fetchImpl: options.fetch\n        });\n        this.accessDelegation = options.accessDelegation?.join(\",\");\n        this.namespaceOps = new NamespaceOperations(this.client, prefix);\n        this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n    }\n    /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */ async listNamespaces(parent) {\n        return this.namespaceOps.listNamespaces(parent);\n    }\n    /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */ async createNamespace(id, metadata) {\n        return this.namespaceOps.createNamespace(id, metadata);\n    }\n    /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */ async dropNamespace(id) {\n        await this.namespaceOps.dropNamespace(id);\n    }\n    /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */ async loadNamespaceMetadata(id) {\n        return this.namespaceOps.loadNamespaceMetadata(id);\n    }\n    /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */ async listTables(namespace) {\n        return this.tableOps.listTables(namespace);\n    }\n    /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTable(namespace, request) {\n        return this.tableOps.createTable(namespace, request);\n    }\n    /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */ async updateTable(id, request) {\n        return this.tableOps.updateTable(id, request);\n    }\n    /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */ async dropTable(id, options) {\n        await this.tableOps.dropTable(id, options);\n    }\n    /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */ async loadTable(id) {\n        return this.tableOps.loadTable(id);\n    }\n    /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */ async namespaceExists(id) {\n        return this.namespaceOps.namespaceExists(id);\n    }\n    /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */ async tableExists(id) {\n        return this.tableOps.tableExists(id);\n    }\n    /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */ async createNamespaceIfNotExists(id, metadata) {\n        return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n    }\n    /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTableIfNotExists(namespace, request) {\n        return this.tableOps.createTableIfNotExists(namespace, request);\n    }\n};\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n    const match = type.match(DECIMAL_REGEX);\n    if (!match) return null;\n    return {\n        precision: parseInt(match[1], 10),\n        scale: parseInt(match[2], 10)\n    };\n}\nfunction parseFixedType(type) {\n    const match = type.match(FIXED_REGEX);\n    if (!match) return null;\n    return {\n        length: parseInt(match[1], 10)\n    };\n}\nfunction isDecimalType(type) {\n    return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n    return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n    const decimalA = parseDecimalType(a);\n    const decimalB = parseDecimalType(b);\n    if (decimalA && decimalB) {\n        return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n    }\n    const fixedA = parseFixedType(a);\n    const fixedB = parseFixedType(b);\n    if (fixedA && fixedB) {\n        return fixedA.length === fixedB.length;\n    }\n    return a === b;\n}\nfunction getCurrentSchema(metadata) {\n    return metadata.schemas.find((s)=>s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\n //# sourceMappingURL=index.mjs.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLDZCQUE2QjtBQUM3QixJQUFJQSxlQUFlLGNBQWNDO0lBQy9CQyxZQUFZQyxPQUFPLEVBQUVDLElBQUksQ0FBRTtRQUN6QixLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBR0YsS0FBS0UsTUFBTTtRQUN6QixJQUFJLENBQUNDLFdBQVcsR0FBR0gsS0FBS0csV0FBVztRQUNuQyxJQUFJLENBQUNDLFdBQVcsR0FBR0osS0FBS0ksV0FBVztRQUNuQyxJQUFJLENBQUNDLE9BQU8sR0FBR0wsS0FBS0ssT0FBTztRQUMzQixJQUFJLENBQUNDLG9CQUFvQixHQUFHTixLQUFLRyxXQUFXLEtBQUssaUNBQWlDO1lBQUM7WUFBSztZQUFLO1NBQUksQ0FBQ0ksUUFBUSxDQUFDUCxLQUFLRSxNQUFNLEtBQUtGLEtBQUtHLFdBQVcsRUFBRUksU0FBUyxtQkFBbUI7SUFDM0s7SUFDQTs7R0FFQyxHQUNEQyxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNOLE1BQU0sS0FBSztJQUN6QjtJQUNBOztHQUVDLEdBQ0RPLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQ1AsTUFBTSxLQUFLO0lBQ3pCO0lBQ0E7O0dBRUMsR0FDRFEsMEJBQTBCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDUixNQUFNLEtBQUs7SUFDekI7QUFDRjtBQUVBLG1CQUFtQjtBQUNuQixTQUFTUyxTQUFTQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsS0FBSztJQUNwQyxNQUFNQyxNQUFNLElBQUlDLElBQUlILE1BQU1EO0lBQzFCLElBQUlFLE9BQU87UUFDVCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNOLE9BQVE7WUFDaEQsSUFBSUksVUFBVSxLQUFLLEdBQUc7Z0JBQ3BCSCxJQUFJTSxZQUFZ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O0lBQzFCLE1BQU1zRSxRQUFRdEUsS0FBS3NFLEtBQUssQ0FBQ0Y7SUFDekIsSUFBSSxDQUFDRSxPQUFPLE9BQU87SUFDbkIsT0FBTztRQUNMSyxRQUFRSCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTTSxjQUFjNUUsSUFBSTtJQUN6QixPQUFPbUUsY0FBY1UsSUFBSSxDQUFDN0U7QUFDNUI7QUFDQSxTQUFTOEUsWUFBWTlFLElBQUk7SUFDdkIsT0FBT29FLFlBQVlTLElBQUksQ0FBQzdFO0FBQzFCO0FBQ0EsU0FBUytFLFdBQVdDLENBQUMsRUFBRUMsQ0FBQztJQUN0QixNQUFNQyxXQUFXYixpQkFBaUJXO0lBQ2xDLE1BQU1HLFdBQVdkLGlCQUFpQlk7SUFDbEMsSUFBSUMsWUFBWUMsVUFBVTtRQUN4QixPQUFPRCxTQUFTWCxTQUFTLEtBQUtZLFNBQVNaLFNBQVMsSUFBSVcsU0FBU1QsS0FBSyxLQUFLVSxTQUFTVixLQUFLO0lBQ3ZGO0lBQ0EsTUFBTVcsU0FBU1YsZUFBZU07SUFDOUIsTUFBTUssU0FBU1gsZUFBZU87SUFDOUIsSUFBSUcsVUFBVUMsUUFBUTtRQUNwQixPQUFPRCxPQUFPVCxNQUFNLEtBQUtVLE9BQU9WLE1BQU07SUFDeEM7SUFDQSxPQUFPSyxNQUFNQztBQUNmO0FBQ0EsU0FBU0ssaUJBQWlCNUMsUUFBUTtJQUNoQyxPQUFPQSxTQUFTNkMsT0FBTyxDQUFDQyxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsQ0FBQyxDQUFDLFlBQVksS0FBSy9DLFFBQVEsQ0FBQyxvQkFBb0I7QUFDdEY7QUFFd0ksQ0FDeEksa0NBQWtDO0NBQ2xDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Jlc3RhdXJhbnQtbWVudS1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9kaXN0L2luZGV4Lm1qcz9mY2FlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMvSWNlYmVyZ0Vycm9yLnRzXG52YXIgSWNlYmVyZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkljZWJlcmdFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0cy5zdGF0dXM7XG4gICAgdGhpcy5pY2ViZXJnVHlwZSA9IG9wdHMuaWNlYmVyZ1R5cGU7XG4gICAgdGhpcy5pY2ViZXJnQ29kZSA9IG9wdHMuaWNlYmVyZ0NvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gb3B0cy5kZXRhaWxzO1xuICAgIHRoaXMuaXNDb21taXRTdGF0ZVVua25vd24gPSBvcHRzLmljZWJlcmdUeXBlID09PSBcIkNvbW1pdFN0YXRlVW5rbm93bkV4Y2VwdGlvblwiIHx8IFs1MDAsIDUwMiwgNTA0XS5pbmNsdWRlcyhvcHRzLnN0YXR1cykgJiYgb3B0cy5pY2ViZXJnVHlwZT8uaW5jbHVkZXMoXCJDb21taXRTdGF0ZVwiKSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIDQwNCBOb3QgRm91bmQgZXJyb3IuXG4gICAqL1xuICBpc05vdEZvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gNDA0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDA5IENvbmZsaWN0IGVycm9yLlxuICAgKi9cbiAgaXNDb25mbGljdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDQwOTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIDQxOSBBdXRoZW50aWNhdGlvbiBUaW1lb3V0IGVycm9yLlxuICAgKi9cbiAgaXNBdXRoZW50aWNhdGlvblRpbWVvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSA0MTk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy91cmwudHNcbmZ1bmN0aW9uIGJ1aWxkVXJsKGJhc2VVcmwsIHBhdGgsIHF1ZXJ5KSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocGF0aCwgYmFzZVVybCk7XG4gIGlmIChxdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuLy8gc3JjL2h0dHAvY3JlYXRlRmV0Y2hDbGllbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkQXV0aEhlYWRlcnMoYXV0aCkge1xuICBpZiAoIWF1dGggfHwgYXV0aC50eXBlID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoYXV0aC50eXBlID09PSBcImJlYXJlclwiKSB7XG4gICAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGgudG9rZW59YCB9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiaGVhZGVyXCIpIHtcbiAgICByZXR1cm4geyBbYXV0aC5uYW1lXTogYXV0aC52YWx1ZSB9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICByZXR1cm4gYXdhaXQgYXV0aC5nZXRIZWFkZXJzKCk7XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDbGllbnQob3B0aW9ucykge1xuICBjb25zdCBmZXRjaEZuID0gb3B0aW9ucy5mZXRjaEltcGwgPz8gZ2xvYmFsVGhpcy5mZXRjaDtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyByZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhdGgsXG4gICAgICBxdWVyeSxcbiAgICAgIGJvZHksXG4gICAgICBoZWFkZXJzXG4gICAgfSkge1xuICAgICAgY29uc3QgdXJsID0gYnVpbGRVcmwob3B0aW9ucy5iYXNlVXJsLCBwYXRoLCBxdWVyeSk7XG4gICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IGJ1aWxkQXV0aEhlYWRlcnMob3B0aW9ucy5hdXRoKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoRm4odXJsLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmJvZHkgPyB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0gOiB7fSxcbiAgICAgICAgICAuLi5hdXRoSGVhZGVycyxcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIGNvbnN0IGlzSnNvbiA9IChyZXMuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIikuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgY29uc3QgZGF0YSA9IGlzSnNvbiAmJiB0ZXh0ID8gSlNPTi5wYXJzZSh0ZXh0KSA6IHRleHQ7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJCb2R5ID0gaXNKc29uID8gZGF0YSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZXJyb3JEZXRhaWwgPSBlcnJCb2R5Py5lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IEljZWJlcmdFcnJvcihcbiAgICAgICAgICBlcnJvckRldGFpbD8ubWVzc2FnZSA/PyBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXMuc3RhdHVzfWAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgaWNlYmVyZ1R5cGU6IGVycm9yRGV0YWlsPy50eXBlLFxuICAgICAgICAgICAgaWNlYmVyZ0NvZGU6IGVycm9yRGV0YWlsPy5jb2RlLFxuICAgICAgICAgICAgZGV0YWlsczogZXJyQm9keVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogcmVzLnN0YXR1cywgaGVhZGVyczogcmVzLmhlYWRlcnMsIGRhdGEgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9jYXRhbG9nL25hbWVzcGFjZXMudHNcbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aChuYW1lc3BhY2UpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZS5qb2luKFwiXHUwMDFmXCIpO1xufVxudmFyIE5hbWVzcGFjZU9wZXJhdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcHJlZml4ID0gXCJcIikge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICB9XG4gIGFzeW5jIGxpc3ROYW1lc3BhY2VzKHBhcmVudCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gcGFyZW50ID8geyBwYXJlbnQ6IG5hbWVzcGFjZVRvUGF0aChwYXJlbnQubmFtZXNwYWNlKSB9IDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlc2AsXG4gICAgICBxdWVyeVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm5hbWVzcGFjZXMubWFwKChucykgPT4gKHsgbmFtZXNwYWNlOiBucyB9KSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBuYW1lc3BhY2U6IGlkLm5hbWVzcGFjZSxcbiAgICAgIHByb3BlcnRpZXM6IG1ldGFkYXRhPy5wcm9wZXJ0aWVzXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzYCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBkcm9wTmFtZXNwYWNlKGlkKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICB9KTtcbiAgfVxuICBhc3luYyBsb2FkTmFtZXNwYWNlTWV0YWRhdGEoaWQpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgoaWQubmFtZXNwYWNlKX1gXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BlcnRpZXM6IHJlc3BvbnNlLmRhdGEucHJvcGVydGllc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgbmFtZXNwYWNlRXhpc3RzKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiLFxuICAgICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2F0YWxvZy90YWJsZXMudHNcbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlKSB7XG4gIHJldHVybiBuYW1lc3BhY2Uuam9pbihcIlx1MDAxZlwiKTtcbn1cbnZhciBUYWJsZU9wZXJhdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcHJlZml4ID0gXCJcIiwgYWNjZXNzRGVsZWdhdGlvbikge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYWNjZXNzRGVsZWdhdGlvbiA9IGFjY2Vzc0RlbGVnYXRpb247XG4gIH1cbiAgYXN5bmMgbGlzdFRhYmxlcyhuYW1lc3BhY2UpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKG5hbWVzcGFjZS5uYW1lc3BhY2UpfS90YWJsZXNgXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuaWRlbnRpZmllcnM7XG4gIH1cbiAgYXN5bmMgY3JlYXRlVGFibGUobmFtZXNwYWNlLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKG5hbWVzcGFjZS5uYW1lc3BhY2UpfS90YWJsZXNgLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXRhZGF0YTtcbiAgfVxuICBhc3luYyB1cGRhdGVUYWJsZShpZCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgXCJtZXRhZGF0YS1sb2NhdGlvblwiOiByZXNwb25zZS5kYXRhW1wibWV0YWRhdGEtbG9jYXRpb25cIl0sXG4gICAgICBtZXRhZGF0YTogcmVzcG9uc2UuZGF0YS5tZXRhZGF0YVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZHJvcFRhYmxlKGlkLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgcXVlcnk6IHsgcHVyZ2VSZXF1ZXN0ZWQ6IFN0cmluZyhvcHRpb25zPy5wdXJnZSA/PyBmYWxzZSkgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGxvYWRUYWJsZShpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgICBoZWFkZXJzW1wiWC1JY2ViZXJnLUFjY2Vzcy1EZWxlZ2F0aW9uXCJdID0gdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXRhZGF0YTtcbiAgfVxuICBhc3luYyB0YWJsZUV4aXN0cyhpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgICBoZWFkZXJzW1wiWC1JY2ViZXJnLUFjY2Vzcy1EZWxlZ2F0aW9uXCJdID0gdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCIsXG4gICAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlVGFibGUobmFtZXNwYWNlLCByZXF1ZXN0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvYWRUYWJsZSh7IG5hbWVzcGFjZTogbmFtZXNwYWNlLm5hbWVzcGFjZSwgbmFtZTogcmVxdWVzdC5uYW1lIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2F0YWxvZy9JY2ViZXJnUmVzdENhdGFsb2cudHNcbnZhciBJY2ViZXJnUmVzdENhdGFsb2cgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjYXRhbG9nIGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGxldCBwcmVmaXggPSBcInYxXCI7XG4gICAgaWYgKG9wdGlvbnMuY2F0YWxvZ05hbWUpIHtcbiAgICAgIHByZWZpeCArPSBgLyR7b3B0aW9ucy5jYXRhbG9nTmFtZX1gO1xuICAgIH1cbiAgICBjb25zdCBiYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJsLmVuZHNXaXRoKFwiL1wiKSA/IG9wdGlvbnMuYmFzZVVybCA6IGAke29wdGlvbnMuYmFzZVVybH0vYDtcbiAgICB0aGlzLmNsaWVudCA9IGNyZWF0ZUZldGNoQ2xpZW50KHtcbiAgICAgIGJhc2VVcmwsXG4gICAgICBhdXRoOiBvcHRpb25zLmF1dGgsXG4gICAgICBmZXRjaEltcGw6IG9wdGlvbnMuZmV0Y2hcbiAgICB9KTtcbiAgICB0aGlzLmFjY2Vzc0RlbGVnYXRpb24gPSBvcHRpb25zLmFjY2Vzc0RlbGVnYXRpb24/LmpvaW4oXCIsXCIpO1xuICAgIHRoaXMubmFtZXNwYWNlT3BzID0gbmV3IE5hbWVzcGFjZU9wZXJhdGlvbnModGhpcy5jbGllbnQsIHByZWZpeCk7XG4gICAgdGhpcy50YWJsZU9wcyA9IG5ldyBUYWJsZU9wZXJhdGlvbnModGhpcy5jbGllbnQsIHByZWZpeCwgdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIG5hbWVzcGFjZXMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnQgLSBPcHRpb25hbCBwYXJlbnQgbmFtZXNwYWNlIHRvIGxpc3QgY2hpbGRyZW4gdW5kZXJcbiAgICogQHJldHVybnMgQXJyYXkgb2YgbmFtZXNwYWNlIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogLy8gTGlzdCBhbGwgdG9wLWxldmVsIG5hbWVzcGFjZXNcbiAgICogY29uc3QgbmFtZXNwYWNlcyA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKTtcbiAgICpcbiAgICogLy8gTGlzdCBuYW1lc3BhY2VzIHVuZGVyIGEgcGFyZW50XG4gICAqIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsaXN0TmFtZXNwYWNlcyhwYXJlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMubGlzdE5hbWVzcGFjZXMocGFyZW50KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBuYW1lc3BhY2UgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBPcHRpb25hbCBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIFJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGNyZWF0ZWQgbmFtZXNwYWNlIGFuZCBpdHMgcHJvcGVydGllc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2UoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nIH0gfVxuICAgKiApO1xuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5uYW1lc3BhY2UpOyAvLyBbJ2FuYWx5dGljcyddXG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLnByb3BlcnRpZXMpOyAvLyB7IG93bmVyOiAnZGF0YS10ZWFtJywgLi4uIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVOYW1lc3BhY2UoaWQsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBhIG5hbWVzcGFjZSBmcm9tIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBUaGUgbmFtZXNwYWNlIG11c3QgYmUgZW1wdHkgKGNvbnRhaW4gbm8gdGFibGVzKSBiZWZvcmUgaXQgY2FuIGJlIGRyb3BwZWQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGRyb3BcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBhd2FpdCBjYXRhbG9nLmRyb3BOYW1lc3BhY2UoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZHJvcE5hbWVzcGFjZShpZCkge1xuICAgIGF3YWl0IHRoaXMubmFtZXNwYWNlT3BzLmRyb3BOYW1lc3BhY2UoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBtZXRhZGF0YSBmb3IgYSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGxvYWRcbiAgICogQHJldHVybnMgTmFtZXNwYWNlIG1ldGFkYXRhIGluY2x1ZGluZyBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmxvYWROYW1lc3BhY2VNZXRhZGF0YSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEucHJvcGVydGllcyk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbG9hZE5hbWVzcGFjZU1ldGFkYXRhKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmxvYWROYW1lc3BhY2VNZXRhZGF0YShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIGFsbCB0YWJsZXMgaW4gYSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBsaXN0IHRhYmxlcyBmcm9tXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHRhYmxlIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgdGFibGVzID0gYXdhaXQgY2F0YWxvZy5saXN0VGFibGVzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyh0YWJsZXMpOyAvLyBbeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0sIC4uLl1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsaXN0VGFibGVzKG5hbWVzcGFjZSkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmxpc3RUYWJsZXMobmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0YWJsZSBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE5hbWVzcGFjZSB0byBjcmVhdGUgdGhlIHRhYmxlIGluXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGFibGUgY3JlYXRpb24gcmVxdWVzdCBpbmNsdWRpbmcgbmFtZSwgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgZXRjLlxuICAgKiBAcmV0dXJucyBUYWJsZSBtZXRhZGF0YSBmb3IgdGhlIGNyZWF0ZWQgdGFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlVGFibGUoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7XG4gICAqICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICogICAgICAgZmllbGRzOiBbXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfVxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMFxuICAgKiAgICAgfSxcbiAgICogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcbiAgICogICAgICAgJ3NwZWMtaWQnOiAwLFxuICAgKiAgICAgICBmaWVsZHM6IFtcbiAgICogICAgICAgICB7IHNvdXJjZV9pZDogMiwgZmllbGRfaWQ6IDEwMDAsIG5hbWU6ICd0c19kYXknLCB0cmFuc2Zvcm06ICdkYXknIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5jcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIHRhYmxlJ3MgbWV0YWRhdGEuXG4gICAqXG4gICAqIENhbiB1cGRhdGUgdGhlIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIG9yIHByb3BlcnRpZXMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byB1cGRhdGVcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBVcGRhdGUgcmVxdWVzdCB3aXRoIGZpZWxkcyB0byBtb2RpZnlcbiAgICogQHJldHVybnMgUmVzcG9uc2UgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgbG9jYXRpb24gYW5kIHVwZGF0ZWQgdGFibGUgbWV0YWRhdGFcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhdGFsb2cudXBkYXRlVGFibGUoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0sXG4gICAqICAge1xuICAgKiAgICAgcHJvcGVydGllczogeyAncmVhZC5zcGxpdC50YXJnZXQtc2l6ZSc6ICcxMzQyMTc3MjgnIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlWydtZXRhZGF0YS1sb2NhdGlvbiddKTsgLy8gczM6Ly8uLi5cbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UubWV0YWRhdGEpOyAvLyBUYWJsZU1ldGFkYXRhIG9iamVjdFxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMudXBkYXRlVGFibGUoaWQsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBhIHRhYmxlIGZyb20gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gZHJvcFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBkcm9wVGFibGUoaWQsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLnRhYmxlT3BzLmRyb3BUYWJsZShpZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIG1ldGFkYXRhIGZvciBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIGxvYWRcbiAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgaW5jbHVkaW5nIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIGxvY2F0aW9uLCBldGMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmxvYWRUYWJsZSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSk7XG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLnNjaGVtYSk7XG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLmxvY2F0aW9uKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2FkVGFibGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5sb2FkVGFibGUoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBuYW1lc3BhY2UgZXhpc3RzIGluIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBuYW1lc3BhY2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBleGlzdHMgPSBhd2FpdCBjYXRhbG9nLm5hbWVzcGFjZUV4aXN0cyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogY29uc29sZS5sb2coZXhpc3RzKTsgLy8gdHJ1ZSBvciBmYWxzZVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIG5hbWVzcGFjZUV4aXN0cyhpZCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5uYW1lc3BhY2VFeGlzdHMoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSB0YWJsZSBleGlzdHMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gY2hlY2tcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdGFibGUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBleGlzdHMgPSBhd2FpdCBjYXRhbG9nLnRhYmxlRXhpc3RzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogY29uc29sZS5sb2coZXhpc3RzKTsgLy8gdHJ1ZSBvciBmYWxzZVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRhYmxlRXhpc3RzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMudGFibGVFeGlzdHMoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmFtZXNwYWNlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBJZiB0aGUgbmFtZXNwYWNlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIHZvaWQuIElmIGNyZWF0ZWQsIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBjcmVhdGVcbiAgICogQHBhcmFtIG1ldGFkYXRhIC0gT3B0aW9uYWwgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgdGhlIG5hbWVzcGFjZVxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBjcmVhdGVkIG5hbWVzcGFjZSBhbmQgaXRzIHByb3BlcnRpZXMsIG9yIHZvaWQgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nIH0gfVxuICAgKiApO1xuICAgKiBpZiAocmVzcG9uc2UpIHtcbiAgICogICBjb25zb2xlLmxvZygnQ3JlYXRlZDonLCByZXNwb25zZS5uYW1lc3BhY2UpO1xuICAgKiB9IGVsc2Uge1xuICAgKiAgIGNvbnNvbGUubG9nKCdBbHJlYWR5IGV4aXN0cycpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmNyZWF0ZU5hbWVzcGFjZUlmTm90RXhpc3RzKGlkLCBtZXRhZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0YWJsZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogSWYgdGhlIHRhYmxlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIGl0cyBtZXRhZGF0YSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIHRvIGNyZWF0ZSB0aGUgdGFibGUgaW5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUYWJsZSBjcmVhdGlvbiByZXF1ZXN0IGluY2x1ZGluZyBuYW1lLCBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBldGMuXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGZvciB0aGUgY3JlYXRlZCBvciBleGlzdGluZyB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZUlmTm90RXhpc3RzKFxuICAgKiAgIHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0sXG4gICAqICAge1xuICAgKiAgICAgbmFtZTogJ2V2ZW50cycsXG4gICAqICAgICBzY2hlbWE6IHtcbiAgICogICAgICAgdHlwZTogJ3N0cnVjdCcsXG4gICAqICAgICAgIGZpZWxkczogW1xuICAgKiAgICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdpZCcsIHR5cGU6ICdsb25nJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH1cbiAgICogICAgICAgXSxcbiAgICogICAgICAgJ3NjaGVtYS1pZCc6IDBcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5jcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL3R5cGVzLnRzXG52YXIgREVDSU1BTF9SRUdFWCA9IC9eZGVjaW1hbFxccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKSQvO1xudmFyIEZJWEVEX1JFR0VYID0gL15maXhlZFxccypcXFtcXHMqKFxcZCspXFxzKlxcXSQvO1xuZnVuY3Rpb24gcGFyc2VEZWNpbWFsVHlwZSh0eXBlKSB7XG4gIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChERUNJTUFMX1JFR0VYKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgcHJlY2lzaW9uOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxuICAgIHNjYWxlOiBwYXJzZUludChtYXRjaFsyXSwgMTApXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUZpeGVkVHlwZSh0eXBlKSB7XG4gIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChGSVhFRF9SRUdFWCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIGxlbmd0aDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKVxuICB9O1xufVxuZnVuY3Rpb24gaXNEZWNpbWFsVHlwZSh0eXBlKSB7XG4gIHJldHVybiBERUNJTUFMX1JFR0VYLnRlc3QodHlwZSk7XG59XG5mdW5jdGlvbiBpc0ZpeGVkVHlwZSh0eXBlKSB7XG4gIHJldHVybiBGSVhFRF9SRUdFWC50ZXN0KHR5cGUpO1xufVxuZnVuY3Rpb24gdHlwZXNFcXVhbChhLCBiKSB7XG4gIGNvbnN0IGRlY2ltYWxBID0gcGFyc2VEZWNpbWFsVHlwZShhKTtcbiAgY29uc3QgZGVjaW1hbEIgPSBwYXJzZURlY2ltYWxUeXBlKGIpO1xuICBpZiAoZGVjaW1hbEEgJiYgZGVjaW1hbEIpIHtcbiAgICByZXR1cm4gZGVjaW1hbEEucHJlY2lzaW9uID09PSBkZWNpbWFsQi5wcmVjaXNpb24gJiYgZGVjaW1hbEEuc2NhbGUgPT09IGRlY2ltYWxCLnNjYWxlO1xuICB9XG4gIGNvbnN0IGZpeGVkQSA9IHBhcnNlRml4ZWRUeXBlKGEpO1xuICBjb25zdCBmaXhlZEIgPSBwYXJzZUZpeGVkVHlwZShiKTtcbiAgaWYgKGZpeGVkQSAmJiBmaXhlZEIpIHtcbiAgICByZXR1cm4gZml4ZWRBLmxlbmd0aCA9PT0gZml4ZWRCLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY2hlbWEobWV0YWRhdGEpIHtcbiAgcmV0dXJuIG1ldGFkYXRhLnNjaGVtYXMuZmluZCgocykgPT4gc1tcInNjaGVtYS1pZFwiXSA9PT0gbWV0YWRhdGFbXCJjdXJyZW50LXNjaGVtYS1pZFwiXSk7XG59XG5cbmV4cG9ydCB7IEljZWJlcmdFcnJvciwgSWNlYmVyZ1Jlc3RDYXRhbG9nLCBnZXRDdXJyZW50U2NoZW1hLCBpc0RlY2ltYWxUeXBlLCBpc0ZpeGVkVHlwZSwgcGFyc2VEZWNpbWFsVHlwZSwgcGFyc2VGaXhlZFR5cGUsIHR5cGVzRXF1YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiSWNlYmVyZ0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcHRzIiwibmFtZSIsInN0YXR1cyIsImljZWJlcmdUeXBlIiwiaWNlYmVyZ0NvZGUiLCJkZXRhaWxzIiwiaXNDb21taXRTdGF0ZVVua25vd24iLCJpbmNsdWRlcyIsImlzTm90Rm91bmQiLCJpc0NvbmZsaWN0IiwiaXNBdXRoZW50aWNhdGlvblRpbWVvdXQiLCJidWlsZFVybCIsImJhc2VVcmwiLCJwYXRoIiwicXVlcnkiLCJ1cmwiLCJVUkwiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJ0b1N0cmluZyIsImJ1aWxkQXV0aEhlYWRlcnMiLCJhdXRoIiwidHlwZSIsIkF1dGhvcml6YXRpb24iLCJ0b2tlbiIsImdldEhlYWRlcnMiLCJjcmVhdGVGZXRjaENsaWVudCIsIm9wdGlvbnMiLCJmZXRjaEZuIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwicmVxdWVzdCIsIm1ldGhvZCIsImJvZHkiLCJoZWFkZXJzIiwiYXV0aEhlYWRlcnMiLCJyZXMiLCJKU09OIiwic3RyaW5naWZ5IiwidGV4dCIsImlzSnNvbiIsImdldCIsImRhdGEiLCJwYXJzZSIsIm9rIiwiZXJyQm9keSIsImVycm9yRGV0YWlsIiwiZXJyb3IiLCJjb2RlIiwibmFtZXNwYWNlVG9QYXRoIiwibmFtZXNwYWNlIiwiam9pbiIsIk5hbWVzcGFjZU9wZXJhdGlvbnMiLCJjbGllbnQiLCJwcmVmaXgiLCJsaXN0TmFtZXNwYWNlcyIsInBhcmVudCIsInJlc3BvbnNlIiwibmFtZXNwYWNlcyIsIm1hcCIsIm5zIiwiY3JlYXRlTmFtZXNwYWNlIiwiaWQiLCJtZXRhZGF0YSIsInByb3BlcnRpZXMiLCJkcm9wTmFtZXNwYWNlIiwibG9hZE5hbWVzcGFjZU1ldGFkYXRhIiwibmFtZXNwYWNlRXhpc3RzIiwiY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMiLCJuYW1lc3BhY2VUb1BhdGgyIiwiVGFibGVPcGVyYXRpb25zIiwiYWNjZXNzRGVsZWdhdGlvbiIsImxpc3RUYWJsZXMiLCJpZGVudGlmaWVycyIsImNyZWF0ZVRhYmxlIiwidXBkYXRlVGFibGUiLCJkcm9wVGFibGUiLCJwdXJnZVJlcXVlc3RlZCIsIlN0cmluZyIsInB1cmdlIiwibG9hZFRhYmxlIiwidGFibGVFeGlzdHMiLCJjcmVhdGVUYWJsZUlmTm90RXhpc3RzIiwiSWNlYmVyZ1Jlc3RDYXRhbG9nIiwiY2F0YWxvZ05hbWUiLCJlbmRzV2l0aCIsIm5hbWVzcGFjZU9wcyIsInRhYmxlT3BzIiwiREVDSU1BTF9SRUdFWCIsIkZJWEVEX1JFR0VYIiwicGFyc2VEZWNpbWFsVHlwZSIsIm1hdGNoIiwicHJlY2lzaW9uIiwicGFyc2VJbnQiLCJzY2FsZSIsInBhcnNlRml4ZWRUeXBlIiwibGVuZ3RoIiwiaXNEZWNpbWFsVHlwZSIsInRlc3QiLCJpc0ZpeGVkVHlwZSIsInR5cGVzRXF1YWwiLCJhIiwiYiIsImRlY2ltYWxBIiwiZGVjaW1hbEIiLCJmaXhlZEEiLCJmaXhlZEIiLCJnZXRDdXJyZW50U2NoZW1hIiwic2NoZW1hcyIsImZpbmQiLCJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/iceberg-js/dist/index.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/iceberg-js/dist/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/iceberg-js/dist/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IcebergError: () => (/* binding */ IcebergError),\n/* harmony export */   IcebergRestCatalog: () => (/* binding */ IcebergRestCatalog),\n/* harmony export */   getCurrentSchema: () => (/* binding */ getCurrentSchema),\n/* harmony export */   isDecimalType: () => (/* binding */ isDecimalType),\n/* harmony export */   isFixedType: () => (/* binding */ isFixedType),\n/* harmony export */   parseDecimalType: () => (/* binding */ parseDecimalType),\n/* harmony export */   parseFixedType: () => (/* binding */ parseFixedType),\n/* harmony export */   typesEqual: () => (/* binding */ typesEqual)\n/* harmony export */ });\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n    constructor(message, opts){\n        super(message);\n        this.name = \"IcebergError\";\n        this.status = opts.status;\n        this.icebergType = opts.icebergType;\n        this.icebergCode = opts.icebergCode;\n        this.details = opts.details;\n        this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [\n            500,\n            502,\n            504\n        ].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\n    }\n    /**\n   * Returns true if the error is a 404 Not Found error.\n   */ isNotFound() {\n        return this.status === 404;\n    }\n    /**\n   * Returns true if the error is a 409 Conflict error.\n   */ isConflict() {\n        return this.status === 409;\n    }\n    /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */ isAuthenticationTimeout() {\n        return this.status === 419;\n    }\n};\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n    const url = new URL(path, baseUrl);\n    if (query) {\n        for (const [key, value] of Object.entries(query)){\n            if (value !== void 0) {\n                url.searchParams.set(key, value);\n            }\n        }\n    }\n    return url.toString();\n}\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n    if (!auth || auth.type === \"none\") {\n        return {};\n    }\n    if (auth.type === \"bearer\") {\n        return {\n            Authorization: `Bearer ${auth.token}`\n        };\n    }\n    if (auth.type === \"header\") {\n        return {\n            [auth.name]: auth.value\n        };\n    }\n    if (auth.type === \"custom\") {\n        return await auth.getHeaders();\n    }\n    return {};\n}\nfunction createFetchClient(options) {\n    const fetchFn = options.fetchImpl ?? globalThis.fetch;\n    return {\n        async request ({ method, path, query, body, headers }) {\n            const url = buildUrl(options.baseUrl, path, query);\n            const authHeaders = await buildAuthHeaders(options.auth);\n            const res = await fetchFn(url, {\n                method,\n                headers: {\n                    ...body ? {\n                        \"Content-Type\": \"application/json\"\n                    } : {},\n                    ...authHeaders,\n                    ...headers\n                },\n                body: body ? JSON.stringify(body) : void 0\n            });\n            const text = await res.text();\n            const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n            const data = isJson && text ? JSON.parse(text) : text;\n            if (!res.ok) {\n                const errBody = isJson ? data : void 0;\n                const errorDetail = errBody?.error;\n                throw new IcebergError(errorDetail?.message ?? `Request failed with status ${res.status}`, {\n                    status: res.status,\n                    icebergType: errorDetail?.type,\n                    icebergCode: errorDetail?.code,\n                    details: errBody\n                });\n            }\n            return {\n                status: res.status,\n                headers: res.headers,\n                data\n            };\n        }\n    };\n}\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar NamespaceOperations = class {\n    constructor(client, prefix = \"\"){\n        this.client = client;\n        this.prefix = prefix;\n    }\n    async listNamespaces(parent) {\n        const query = parent ? {\n            parent: namespaceToPath(parent.namespace)\n        } : void 0;\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces`,\n            query\n        });\n        return response.data.namespaces.map((ns)=>({\n                namespace: ns\n            }));\n    }\n    async createNamespace(id, metadata) {\n        const request = {\n            namespace: id.namespace,\n            properties: metadata?.properties\n        };\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces`,\n            body: request\n        });\n        return response.data;\n    }\n    async dropNamespace(id) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n    }\n    async loadNamespaceMetadata(id) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n        return {\n            properties: response.data.properties\n        };\n    }\n    async namespaceExists(id) {\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createNamespaceIfNotExists(id, metadata) {\n        try {\n            return await this.createNamespace(id, metadata);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return;\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar TableOperations = class {\n    constructor(client, prefix = \"\", accessDelegation){\n        this.client = client;\n        this.prefix = prefix;\n        this.accessDelegation = accessDelegation;\n    }\n    async listTables(namespace) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\n        });\n        return response.data.identifiers;\n    }\n    async createTable(namespace, request) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\n            body: request,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async updateTable(id, request) {\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            body: request\n        });\n        return {\n            \"metadata-location\": response.data[\"metadata-location\"],\n            metadata: response.data.metadata\n        };\n    }\n    async dropTable(id, options) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            query: {\n                purgeRequested: String(options?.purge ?? false)\n            }\n        });\n    }\n    async loadTable(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async tableExists(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n                headers\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createTableIfNotExists(namespace, request) {\n        try {\n            return await this.createTable(namespace, request);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return await this.loadTable({\n                    namespace: namespace.namespace,\n                    name: request.name\n                });\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n    /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */ constructor(options){\n        let prefix = \"v1\";\n        if (options.catalogName) {\n            prefix += `/${options.catalogName}`;\n        }\n        const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\n        this.client = createFetchClient({\n            baseUrl,\n            auth: options.auth,\n            fetchImpl: options.fetch\n        });\n        this.accessDelegation = options.accessDelegation?.join(\",\");\n        this.namespaceOps = new NamespaceOperations(this.client, prefix);\n        this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n    }\n    /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */ async listNamespaces(parent) {\n        return this.namespaceOps.listNamespaces(parent);\n    }\n    /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */ async createNamespace(id, metadata) {\n        return this.namespaceOps.createNamespace(id, metadata);\n    }\n    /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */ async dropNamespace(id) {\n        await this.namespaceOps.dropNamespace(id);\n    }\n    /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */ async loadNamespaceMetadata(id) {\n        return this.namespaceOps.loadNamespaceMetadata(id);\n    }\n    /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */ async listTables(namespace) {\n        return this.tableOps.listTables(namespace);\n    }\n    /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTable(namespace, request) {\n        return this.tableOps.createTable(namespace, request);\n    }\n    /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */ async updateTable(id, request) {\n        return this.tableOps.updateTable(id, request);\n    }\n    /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */ async dropTable(id, options) {\n        await this.tableOps.dropTable(id, options);\n    }\n    /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */ async loadTable(id) {\n        return this.tableOps.loadTable(id);\n    }\n    /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */ async namespaceExists(id) {\n        return this.namespaceOps.namespaceExists(id);\n    }\n    /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */ async tableExists(id) {\n        return this.tableOps.tableExists(id);\n    }\n    /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */ async createNamespaceIfNotExists(id, metadata) {\n        return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n    }\n    /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTableIfNotExists(namespace, request) {\n        return this.tableOps.createTableIfNotExists(namespace, request);\n    }\n};\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n    const match = type.match(DECIMAL_REGEX);\n    if (!match) return null;\n    return {\n        precision: parseInt(match[1], 10),\n        scale: parseInt(match[2], 10)\n    };\n}\nfunction parseFixedType(type) {\n    const match = type.match(FIXED_REGEX);\n    if (!match) return null;\n    return {\n        length: parseInt(match[1], 10)\n    };\n}\nfunction isDecimalType(type) {\n    return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n    return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n    const decimalA = parseDecimalType(a);\n    const decimalB = parseDecimalType(b);\n    if (decimalA && decimalB) {\n        return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n    }\n    const fixedA = parseFixedType(a);\n    const fixedB = parseFixedType(b);\n    if (fixedA && fixedB) {\n        return fixedA.length === fixedB.length;\n    }\n    return a === b;\n}\nfunction getCurrentSchema(metadata) {\n    return metadata.schemas.find((s)=>s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\n //# sourceMappingURL=index.mjs.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pY2ViZXJnLWpzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQzdCLElBQUlBLGVBQWUsY0FBY0M7SUFDL0JDLFlBQVlDLE9BQU8sRUFBRUMsSUFBSSxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHRixLQUFLRSxNQUFNO1FBQ3pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHSCxLQUFLRyxXQUFXO1FBQ25DLElBQUksQ0FBQ0MsV0FBVyxHQUFHSixLQUFLSSxXQUFXO1FBQ25DLElBQUksQ0FBQ0MsT0FBTyxHQUFHTCxLQUFLSyxPQUFPO1FBQzNCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUdOLEtBQUtHLFdBQVcsS0FBSyxpQ0FBaUM7WUFBQztZQUFLO1lBQUs7U0FBSSxDQUFDSSxRQUFRLENBQUNQLEtBQUtFLE1BQU0sS0FBS0YsS0FBS0csV0FBVyxFQUFFSSxTQUFTLG1CQUFtQjtJQUMzSztJQUNBOztHQUVDLEdBQ0RDLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQ04sTUFBTSxLQUFLO0lBQ3pCO0lBQ0E7O0dBRUMsR0FDRE8sYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDUCxNQUFNLEtBQUs7SUFDekI7SUFDQTs7R0FFQyxHQUNEUSwwQkFBMEI7UUFDeEIsT0FBTyxJQUFJLENBQUNSLE1BQU0sS0FBSztJQUN6QjtBQUNGO0FBRUEsbUJBQW1CO0FBQ25CLFNBQVNTLFNBQVNDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxLQUFLO0lBQ3BDLE1BQU1DLE1BQU0sSUFBSUMsSUFBSUgsTUFBTUQ7SUFDMUIsSUFBSUUsT0FBTztRQUNULEtBQUssTUFBTSxDQUFDRyxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ04sT0FBUTtZQUNoRCxJQUFJSSxVQUFVLEtBQUssR0FBRztnQkFDcEJI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ZUFBZTFFLElBQUk7SUFDMUIsTUFBTXNFLFFBQVF0RSxLQUFLc0UsS0FBSyxDQUFDRjtJQUN6QixJQUFJLENBQUNFLE9BQU8sT0FBTztJQUNuQixPQUFPO1FBQ0xLLFFBQVFILFNBQVNGLEtBQUssQ0FBQyxFQUFFLEVBQUU7SUFDN0I7QUFDRjtBQUNBLFNBQVNNLGNBQWM1RSxJQUFJO0lBQ3pCLE9BQU9tRSxjQUFjVSxJQUFJLENBQUM3RTtBQUM1QjtBQUNBLFNBQVM4RSxZQUFZOUUsSUFBSTtJQUN2QixPQUFPb0UsWUFBWVMsSUFBSSxDQUFDN0U7QUFDMUI7QUFDQSxTQUFTK0UsV0FBV0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ3RCLE1BQU1DLFdBQVdiLGlCQUFpQlc7SUFDbEMsTUFBTUcsV0FBV2QsaUJBQWlCWTtJQUNsQyxJQUFJQyxZQUFZQyxVQUFVO1FBQ3hCLE9BQU9ELFNBQVNYLFNBQVMsS0FBS1ksU0FBU1osU0FBUyxJQUFJVyxTQUFTVCxLQUFLLEtBQUtVLFNBQVNWLEtBQUs7SUFDdkY7SUFDQSxNQUFNVyxTQUFTVixlQUFlTTtJQUM5QixNQUFNSyxTQUFTWCxlQUFlTztJQUM5QixJQUFJRyxVQUFVQyxRQUFRO1FBQ3BCLE9BQU9ELE9BQU9ULE1BQU0sS0FBS1UsT0FBT1YsTUFBTTtJQUN4QztJQUNBLE9BQU9LLE1BQU1DO0FBQ2Y7QUFDQSxTQUFTSyxpQkFBaUI1QyxRQUFRO0lBQ2hDLE9BQU9BLFNBQVM2QyxPQUFPLENBQUNDLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxDQUFDLENBQUMsWUFBWSxLQUFLL0MsUUFBUSxDQUFDLG9CQUFvQjtBQUN0RjtBQUV3SSxDQUN4SSxrQ0FBa0M7Q0FDbEMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVzdGF1cmFudC1tZW51LXN5c3RlbS8uL25vZGVfbW9kdWxlcy9pY2ViZXJnLWpzL2Rpc3QvaW5kZXgubWpzP2ZjYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9JY2ViZXJnRXJyb3IudHNcbnZhciBJY2ViZXJnRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0cykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiSWNlYmVyZ0Vycm9yXCI7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRzLnN0YXR1cztcbiAgICB0aGlzLmljZWJlcmdUeXBlID0gb3B0cy5pY2ViZXJnVHlwZTtcbiAgICB0aGlzLmljZWJlcmdDb2RlID0gb3B0cy5pY2ViZXJnQ29kZTtcbiAgICB0aGlzLmRldGFpbHMgPSBvcHRzLmRldGFpbHM7XG4gICAgdGhpcy5pc0NvbW1pdFN0YXRlVW5rbm93biA9IG9wdHMuaWNlYmVyZ1R5cGUgPT09IFwiQ29tbWl0U3RhdGVVbmtub3duRXhjZXB0aW9uXCIgfHwgWzUwMCwgNTAyLCA1MDRdLmluY2x1ZGVzKG9wdHMuc3RhdHVzKSAmJiBvcHRzLmljZWJlcmdUeXBlPy5pbmNsdWRlcyhcIkNvbW1pdFN0YXRlXCIpID09PSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDA0IE5vdCBGb3VuZCBlcnJvci5cbiAgICovXG4gIGlzTm90Rm91bmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSA0MDQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSA0MDkgQ29uZmxpY3QgZXJyb3IuXG4gICAqL1xuICBpc0NvbmZsaWN0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gNDA5O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDE5IEF1dGhlbnRpY2F0aW9uIFRpbWVvdXQgZXJyb3IuXG4gICAqL1xuICBpc0F1dGhlbnRpY2F0aW9uVGltZW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDQxOTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3VybC50c1xuZnVuY3Rpb24gYnVpbGRVcmwoYmFzZVVybCwgcGF0aCwgcXVlcnkpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnkpKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvaHR0cC9jcmVhdGVGZXRjaENsaWVudC50c1xuYXN5bmMgZnVuY3Rpb24gYnVpbGRBdXRoSGVhZGVycyhhdXRoKSB7XG4gIGlmICghYXV0aCB8fCBhdXRoLnR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiYmVhcmVyXCIpIHtcbiAgICByZXR1cm4geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aC50b2tlbn1gIH07XG4gIH1cbiAgaWYgKGF1dGgudHlwZSA9PT0gXCJoZWFkZXJcIikge1xuICAgIHJldHVybiB7IFthdXRoLm5hbWVdOiBhdXRoLnZhbHVlIH07XG4gIH1cbiAgaWYgKGF1dGgudHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgIHJldHVybiBhd2FpdCBhdXRoLmdldEhlYWRlcnMoKTtcbiAgfVxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaENsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGZldGNoRm4gPSBvcHRpb25zLmZldGNoSW1wbCA/PyBnbG9iYWxUaGlzLmZldGNoO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIHJlcXVlc3Qoe1xuICAgICAgbWV0aG9kLFxuICAgICAgcGF0aCxcbiAgICAgIHF1ZXJ5LFxuICAgICAgYm9keSxcbiAgICAgIGhlYWRlcnNcbiAgICB9KSB7XG4gICAgICBjb25zdCB1cmwgPSBidWlsZFVybChvcHRpb25zLmJhc2VVcmwsIHBhdGgsIHF1ZXJ5KTtcbiAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgYnVpbGRBdXRoSGVhZGVycyhvcHRpb25zLmF1dGgpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2hGbih1cmwsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uYm9keSA/IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSA6IHt9LFxuICAgICAgICAgIC4uLmF1dGhIZWFkZXJzLFxuICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogYm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgY29uc3QgaXNKc29uID0gKHJlcy5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiKS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBjb25zdCBkYXRhID0gaXNKc29uICYmIHRleHQgPyBKU09OLnBhcnNlKHRleHQpIDogdGV4dDtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IGVyckJvZHkgPSBpc0pzb24gPyBkYXRhIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBlcnJvckRldGFpbCA9IGVyckJvZHk/LmVycm9yO1xuICAgICAgICB0aHJvdyBuZXcgSWNlYmVyZ0Vycm9yKFxuICAgICAgICAgIGVycm9yRGV0YWlsPy5tZXNzYWdlID8/IGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlcy5zdGF0dXN9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICBpY2ViZXJnVHlwZTogZXJyb3JEZXRhaWw/LnR5cGUsXG4gICAgICAgICAgICBpY2ViZXJnQ29kZTogZXJyb3JEZXRhaWw/LmNvZGUsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJCb2R5XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBoZWFkZXJzOiByZXMuaGVhZGVycywgZGF0YSB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2NhdGFsb2cvbmFtZXNwYWNlcy50c1xuZnVuY3Rpb24gbmFtZXNwYWNlVG9QYXRoKG5hbWVzcGFjZSkge1xuICByZXR1cm4gbmFtZXNwYWNlLmpvaW4oXCJcdTAwMWZcIik7XG59XG52YXIgTmFtZXNwYWNlT3BlcmF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwcmVmaXggPSBcIlwiKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gIH1cbiAgYXN5bmMgbGlzdE5hbWVzcGFjZXMocGFyZW50KSB7XG4gICAgY29uc3QgcXVlcnkgPSBwYXJlbnQgPyB7IHBhcmVudDogbmFtZXNwYWNlVG9QYXRoKHBhcmVudC5uYW1lc3BhY2UpIH0gOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzYCxcbiAgICAgIHF1ZXJ5XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubmFtZXNwYWNlcy5tYXAoKG5zKSA9PiAoeyBuYW1lc3BhY2U6IG5zIH0pKTtcbiAgfVxuICBhc3luYyBjcmVhdGVOYW1lc3BhY2UoaWQsIG1ldGFkYXRhKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIG5hbWVzcGFjZTogaWQubmFtZXNwYWNlLFxuICAgICAgcHJvcGVydGllczogbWV0YWRhdGE/LnByb3BlcnRpZXNcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXNgLFxuICAgICAgYm9keTogcmVxdWVzdFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIGRyb3BOYW1lc3BhY2UoaWQpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGxvYWROYW1lc3BhY2VNZXRhZGF0YShpZCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydGllczogcmVzcG9uc2UuZGF0YS5wcm9wZXJ0aWVzXG4gICAgfTtcbiAgfVxuICBhc3luYyBuYW1lc3BhY2VFeGlzdHMoaWQpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCIsXG4gICAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhpZCwgbWV0YWRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwOSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL3RhYmxlcy50c1xuZnVuY3Rpb24gbmFtZXNwYWNlVG9QYXRoMihuYW1lc3BhY2UpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZS5qb2luKFwiXHUwMDFmXCIpO1xufVxudmFyIFRhYmxlT3BlcmF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwcmVmaXggPSBcIlwiLCBhY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uID0gYWNjZXNzRGVsZWdhdGlvbjtcbiAgfVxuICBhc3luYyBsaXN0VGFibGVzKG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlLm5hbWVzcGFjZSl9L3RhYmxlc2BcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5pZGVudGlmaWVycztcbiAgfVxuICBhc3luYyBjcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKHRoaXMuYWNjZXNzRGVsZWdhdGlvbikge1xuICAgICAgaGVhZGVyc1tcIlgtSWNlYmVyZy1BY2Nlc3MtRGVsZWdhdGlvblwiXSA9IHRoaXMuYWNjZXNzRGVsZWdhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlLm5hbWVzcGFjZSl9L3RhYmxlc2AsXG4gICAgICBib2R5OiByZXF1ZXN0LFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1ldGFkYXRhO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgYm9keTogcmVxdWVzdFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBcIm1ldGFkYXRhLWxvY2F0aW9uXCI6IHJlc3BvbnNlLmRhdGFbXCJtZXRhZGF0YS1sb2NhdGlvblwiXSxcbiAgICAgIG1ldGFkYXRhOiByZXNwb25zZS5kYXRhLm1ldGFkYXRhXG4gICAgfTtcbiAgfVxuICBhc3luYyBkcm9wVGFibGUoaWQsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXG4gICAgICBxdWVyeTogeyBwdXJnZVJlcXVlc3RlZDogU3RyaW5nKG9wdGlvbnM/LnB1cmdlID8/IGZhbHNlKSB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbG9hZFRhYmxlKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1ldGFkYXRhO1xuICB9XG4gIGFzeW5jIHRhYmxlRXhpc3RzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIixcbiAgICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9hZFRhYmxlKHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UubmFtZXNwYWNlLCBuYW1lOiByZXF1ZXN0Lm5hbWUgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL0ljZWJlcmdSZXN0Q2F0YWxvZy50c1xudmFyIEljZWJlcmdSZXN0Q2F0YWxvZyA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSWNlYmVyZyBSRVNUIENhdGFsb2cgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGNhdGFsb2cgY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgbGV0IHByZWZpeCA9IFwidjFcIjtcbiAgICBpZiAob3B0aW9ucy5jYXRhbG9nTmFtZSkge1xuICAgICAgcHJlZml4ICs9IGAvJHtvcHRpb25zLmNhdGFsb2dOYW1lfWA7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpID8gb3B0aW9ucy5iYXNlVXJsIDogYCR7b3B0aW9ucy5iYXNlVXJsfS9gO1xuICAgIHRoaXMuY2xpZW50ID0gY3JlYXRlRmV0Y2hDbGllbnQoe1xuICAgICAgYmFzZVVybCxcbiAgICAgIGF1dGg6IG9wdGlvbnMuYXV0aCxcbiAgICAgIGZldGNoSW1wbDogb3B0aW9ucy5mZXRjaFxuICAgIH0pO1xuICAgIHRoaXMuYWNjZXNzRGVsZWdhdGlvbiA9IG9wdGlvbnMuYWNjZXNzRGVsZWdhdGlvbj8uam9pbihcIixcIik7XG4gICAgdGhpcy5uYW1lc3BhY2VPcHMgPSBuZXcgTmFtZXNwYWNlT3BlcmF0aW9ucyh0aGlzLmNsaWVudCwgcHJlZml4KTtcbiAgICB0aGlzLnRhYmxlT3BzID0gbmV3IFRhYmxlT3BlcmF0aW9ucyh0aGlzLmNsaWVudCwgcHJlZml4LCB0aGlzLmFjY2Vzc0RlbGVnYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgbmFtZXNwYWNlcyBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCAtIE9wdGlvbmFsIHBhcmVudCBuYW1lc3BhY2UgdG8gbGlzdCBjaGlsZHJlbiB1bmRlclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBuYW1lc3BhY2UgaWRlbnRpZmllcnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiAvLyBMaXN0IGFsbCB0b3AtbGV2ZWwgbmFtZXNwYWNlc1xuICAgKiBjb25zdCBuYW1lc3BhY2VzID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcygpO1xuICAgKlxuICAgKiAvLyBMaXN0IG5hbWVzcGFjZXMgdW5kZXIgYSBwYXJlbnRcbiAgICogY29uc3QgY2hpbGRyZW4gPSBhd2FpdCBjYXRhbG9nLmxpc3ROYW1lc3BhY2VzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3ROYW1lc3BhY2VzKHBhcmVudCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5saXN0TmFtZXNwYWNlcyhwYXJlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG5hbWVzcGFjZSBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSBuYW1lc3BhY2VcbiAgICogQHJldHVybnMgUmVzcG9uc2UgY29udGFpbmluZyB0aGUgY3JlYXRlZCBuYW1lc3BhY2UgYW5kIGl0cyBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHsgcHJvcGVydGllczogeyBvd25lcjogJ2RhdGEtdGVhbScgfSB9XG4gICAqICk7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLm5hbWVzcGFjZSk7IC8vIFsnYW5hbHl0aWNzJ11cbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UucHJvcGVydGllcyk7IC8vIHsgb3duZXI6ICdkYXRhLXRlYW0nLCAuLi4gfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMuY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIERyb3BzIGEgbmFtZXNwYWNlIGZyb20gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIFRoZSBuYW1lc3BhY2UgbXVzdCBiZSBlbXB0eSAoY29udGFpbiBubyB0YWJsZXMpIGJlZm9yZSBpdCBjYW4gYmUgZHJvcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gZHJvcFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IGNhdGFsb2cuZHJvcE5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBkcm9wTmFtZXNwYWNlKGlkKSB7XG4gICAgYXdhaXQgdGhpcy5uYW1lc3BhY2VPcHMuZHJvcE5hbWVzcGFjZShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIG1ldGFkYXRhIGZvciBhIG5hbWVzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gbG9hZFxuICAgKiBAcmV0dXJucyBOYW1lc3BhY2UgbWV0YWRhdGEgaW5jbHVkaW5nIHByb3BlcnRpZXNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cubG9hZE5hbWVzcGFjZU1ldGFkYXRhKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyhtZXRhZGF0YS5wcm9wZXJ0aWVzKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2FkTmFtZXNwYWNlTWV0YWRhdGEoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMubG9hZE5hbWVzcGFjZU1ldGFkYXRhKGlkKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIHRhYmxlcyBpbiBhIG5hbWVzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGxpc3QgdGFibGVzIGZyb21cbiAgICogQHJldHVybnMgQXJyYXkgb2YgdGFibGUgaWRlbnRpZmllcnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCB0YWJsZXMgPSBhd2FpdCBjYXRhbG9nLmxpc3RUYWJsZXMoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSk7XG4gICAqIGNvbnNvbGUubG9nKHRhYmxlcyk7IC8vIFt7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSwgLi4uXVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3RUYWJsZXMobmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMubGlzdFRhYmxlcyhuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRhYmxlIGluIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIHRvIGNyZWF0ZSB0aGUgdGFibGUgaW5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUYWJsZSBjcmVhdGlvbiByZXF1ZXN0IGluY2x1ZGluZyBuYW1lLCBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBldGMuXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGZvciB0aGUgY3JlYXRlZCB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHtcbiAgICogICAgIG5hbWU6ICdldmVudHMnLFxuICAgKiAgICAgc2NoZW1hOiB7XG4gICAqICAgICAgIHR5cGU6ICdzdHJ1Y3QnLFxuICAgKiAgICAgICBmaWVsZHM6IFtcbiAgICogICAgICAgICB7IGlkOiAxLCBuYW1lOiAnaWQnLCB0eXBlOiAnbG9uZycsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAqICAgICAgICAgeyBpZDogMiwgbmFtZTogJ3RpbWVzdGFtcCcsIHR5cGU6ICd0aW1lc3RhbXAnLCByZXF1aXJlZDogdHJ1ZSB9XG4gICAqICAgICAgIF0sXG4gICAqICAgICAgICdzY2hlbWEtaWQnOiAwXG4gICAqICAgICB9LFxuICAgKiAgICAgJ3BhcnRpdGlvbi1zcGVjJzoge1xuICAgKiAgICAgICAnc3BlYy1pZCc6IDAsXG4gICAqICAgICAgIGZpZWxkczogW1xuICAgKiAgICAgICAgIHsgc291cmNlX2lkOiAyLCBmaWVsZF9pZDogMTAwMCwgbmFtZTogJ3RzX2RheScsIHRyYW5zZm9ybTogJ2RheScgfVxuICAgKiAgICAgICBdXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRhYmxlKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlKG5hbWVzcGFjZSwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGFibGUncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQ2FuIHVwZGF0ZSB0aGUgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgb3IgcHJvcGVydGllcyBvZiBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFVwZGF0ZSByZXF1ZXN0IHdpdGggZmllbGRzIHRvIG1vZGlmeVxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBtZXRhZGF0YSBsb2NhdGlvbiBhbmQgdXBkYXRlZCB0YWJsZSBtZXRhZGF0YVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy51cGRhdGVUYWJsZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSxcbiAgICogICB7XG4gICAqICAgICBwcm9wZXJ0aWVzOiB7ICdyZWFkLnNwbGl0LnRhcmdldC1zaXplJzogJzEzNDIxNzcyOCcgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogY29uc29sZS5sb2cocmVzcG9uc2VbJ21ldGFkYXRhLWxvY2F0aW9uJ10pOyAvLyBzMzovLy4uLlxuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5tZXRhZGF0YSk7IC8vIFRhYmxlTWV0YWRhdGEgb2JqZWN0XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVGFibGUoaWQsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy51cGRhdGVUYWJsZShpZCwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIERyb3BzIGEgdGFibGUgZnJvbSB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byBkcm9wXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogYXdhaXQgY2F0YWxvZy5kcm9wVGFibGUoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGRyb3BUYWJsZShpZCwgb3B0aW9ucykge1xuICAgIGF3YWl0IHRoaXMudGFibGVPcHMuZHJvcFRhYmxlKGlkLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogTG9hZHMgbWV0YWRhdGEgZm9yIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gbG9hZFxuICAgKiBAcmV0dXJucyBUYWJsZSBtZXRhZGF0YSBpbmNsdWRpbmcgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgbG9jYXRpb24sIGV0Yy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cubG9hZFRhYmxlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEuc2NoZW1hKTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEubG9jYXRpb24pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxvYWRUYWJsZShpZCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmxvYWRUYWJsZShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIG5hbWVzcGFjZSBleGlzdHMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5hbWVzcGFjZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGNhdGFsb2cubmFtZXNwYWNlRXhpc3RzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyhleGlzdHMpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbmFtZXNwYWNlRXhpc3RzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLm5hbWVzcGFjZUV4aXN0cyhpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHRhYmxlIGV4aXN0cyBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0YWJsZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGNhdGFsb2cudGFibGVFeGlzdHMoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xuICAgKiBjb25zb2xlLmxvZyhleGlzdHMpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdGFibGVFeGlzdHMoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy50YWJsZUV4aXN0cyhpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuYW1lc3BhY2UgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIElmIHRoZSBuYW1lc3BhY2UgYWxyZWFkeSBleGlzdHMsIHJldHVybnMgdm9pZC4gSWYgY3JlYXRlZCwgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBPcHRpb25hbCBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIFJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGNyZWF0ZWQgbmFtZXNwYWNlIGFuZCBpdHMgcHJvcGVydGllcywgb3Igdm9pZCBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHsgcHJvcGVydGllczogeyBvd25lcjogJ2RhdGEtdGVhbScgfSB9XG4gICAqICk7XG4gICAqIGlmIChyZXNwb25zZSkge1xuICAgKiAgIGNvbnNvbGUubG9nKCdDcmVhdGVkOicsIHJlc3BvbnNlLm5hbWVzcGFjZSk7XG4gICAqIH0gZWxzZSB7XG4gICAqICAgY29uc29sZS5sb2coJ0FscmVhZHkgZXhpc3RzJyk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhpZCwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMuY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRhYmxlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBJZiB0aGUgdGFibGUgYWxyZWFkeSBleGlzdHMsIHJldHVybnMgaXRzIG1ldGFkYXRhIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBOYW1lc3BhY2UgdG8gY3JlYXRlIHRoZSB0YWJsZSBpblxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRhYmxlIGNyZWF0aW9uIHJlcXVlc3QgaW5jbHVkaW5nIG5hbWUsIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIGV0Yy5cbiAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgZm9yIHRoZSBjcmVhdGVkIG9yIGV4aXN0aW5nIHRhYmxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7XG4gICAqICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICogICAgICAgZmllbGRzOiBbXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfVxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMFxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMobmFtZXNwYWNlLCByZXF1ZXN0KTtcbiAgfVxufTtcblxuLy8gc3JjL2NhdGFsb2cvdHlwZXMudHNcbnZhciBERUNJTUFMX1JFR0VYID0gL15kZWNpbWFsXFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqXFwpJC87XG52YXIgRklYRURfUkVHRVggPSAvXmZpeGVkXFxzKlxcW1xccyooXFxkKylcXHMqXFxdJC87XG5mdW5jdGlvbiBwYXJzZURlY2ltYWxUeXBlKHR5cGUpIHtcbiAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKERFQ0lNQUxfUkVHRVgpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBwcmVjaXNpb246IHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXG4gICAgc2NhbGU6IHBhcnNlSW50KG1hdGNoWzJdLCAxMClcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRml4ZWRUeXBlKHR5cGUpIHtcbiAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKEZJWEVEX1JFR0VYKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiBwYXJzZUludChtYXRjaFsxXSwgMTApXG4gIH07XG59XG5mdW5jdGlvbiBpc0RlY2ltYWxUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIERFQ0lNQUxfUkVHRVgudGVzdCh0eXBlKTtcbn1cbmZ1bmN0aW9uIGlzRml4ZWRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIEZJWEVEX1JFR0VYLnRlc3QodHlwZSk7XG59XG5mdW5jdGlvbiB0eXBlc0VxdWFsKGEsIGIpIHtcbiAgY29uc3QgZGVjaW1hbEEgPSBwYXJzZURlY2ltYWxUeXBlKGEpO1xuICBjb25zdCBkZWNpbWFsQiA9IHBhcnNlRGVjaW1hbFR5cGUoYik7XG4gIGlmIChkZWNpbWFsQSAmJiBkZWNpbWFsQikge1xuICAgIHJldHVybiBkZWNpbWFsQS5wcmVjaXNpb24gPT09IGRlY2ltYWxCLnByZWNpc2lvbiAmJiBkZWNpbWFsQS5zY2FsZSA9PT0gZGVjaW1hbEIuc2NhbGU7XG4gIH1cbiAgY29uc3QgZml4ZWRBID0gcGFyc2VGaXhlZFR5cGUoYSk7XG4gIGNvbnN0IGZpeGVkQiA9IHBhcnNlRml4ZWRUeXBlKGIpO1xuICBpZiAoZml4ZWRBICYmIGZpeGVkQikge1xuICAgIHJldHVybiBmaXhlZEEubGVuZ3RoID09PSBmaXhlZEIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjaGVtYShtZXRhZGF0YSkge1xuICByZXR1cm4gbWV0YWRhdGEuc2NoZW1hcy5maW5kKChzKSA9PiBzW1wic2NoZW1hLWlkXCJdID09PSBtZXRhZGF0YVtcImN1cnJlbnQtc2NoZW1hLWlkXCJdKTtcbn1cblxuZXhwb3J0IHsgSWNlYmVyZ0Vycm9yLCBJY2ViZXJnUmVzdENhdGFsb2csIGdldEN1cnJlbnRTY2hlbWEsIGlzRGVjaW1hbFR5cGUsIGlzRml4ZWRUeXBlLCBwYXJzZURlY2ltYWxUeXBlLCBwYXJzZUZpeGVkVHlwZSwgdHlwZXNFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJJY2ViZXJnRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm9wdHMiLCJuYW1lIiwic3RhdHVzIiwiaWNlYmVyZ1R5cGUiLCJpY2ViZXJnQ29kZSIsImRldGFpbHMiLCJpc0NvbW1pdFN0YXRlVW5rbm93biIsImluY2x1ZGVzIiwiaXNOb3RGb3VuZCIsImlzQ29uZmxpY3QiLCJpc0F1dGhlbnRpY2F0aW9uVGltZW91dCIsImJ1aWxkVXJsIiwiYmFzZVVybCIsInBhdGgiLCJxdWVyeSIsInVybCIsIlVSTCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiYnVpbGRBdXRoSGVhZGVycyIsImF1dGgiLCJ0eXBlIiwiQXV0aG9yaXphdGlvbiIsInRva2VuIiwiZ2V0SGVhZGVycyIsImNyZWF0ZUZldGNoQ2xpZW50Iiwib3B0aW9ucyIsImZldGNoRm4iLCJmZXRjaEltcGwiLCJnbG9iYWxUaGlzIiwiZmV0Y2giLCJyZXF1ZXN0IiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJhdXRoSGVhZGVycyIsInJlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0ZXh0IiwiaXNKc29uIiwiZ2V0IiwiZGF0YSIsInBhcnNlIiwib2siLCJlcnJCb2R5IiwiZXJyb3JEZXRhaWwiLCJlcnJvciIsImNvZGUiLCJuYW1lc3BhY2VUb1BhdGgiLCJuYW1lc3BhY2UiLCJqb2luIiwiTmFtZXNwYWNlT3BlcmF0aW9ucyIsImNsaWVudCIsInByZWZpeCIsImxpc3ROYW1lc3BhY2VzIiwicGFyZW50IiwicmVzcG9uc2UiLCJuYW1lc3BhY2VzIiwibWFwIiwibnMiLCJjcmVhdGVOYW1lc3BhY2UiLCJpZCIsIm1ldGFkYXRhIiwicHJvcGVydGllcyIsImRyb3BOYW1lc3BhY2UiLCJsb2FkTmFtZXNwYWNlTWV0YWRhdGEiLCJuYW1lc3BhY2VFeGlzdHMiLCJjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyIsIm5hbWVzcGFjZVRvUGF0aDIiLCJUYWJsZU9wZXJhdGlvbnMiLCJhY2Nlc3NEZWxlZ2F0aW9uIiwibGlzdFRhYmxlcyIsImlkZW50aWZpZXJzIiwiY3JlYXRlVGFibGUiLCJ1cGRhdGVUYWJsZSIsImRyb3BUYWJsZSIsInB1cmdlUmVxdWVzdGVkIiwiU3RyaW5nIiwicHVyZ2UiLCJsb2FkVGFibGUiLCJ0YWJsZUV4aXN0cyIsImNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMiLCJJY2ViZXJnUmVzdENhdGFsb2ciLCJjYXRhbG9nTmFtZSIsImVuZHNXaXRoIiwibmFtZXNwYWNlT3BzIiwidGFibGVPcHMiLCJERUNJTUFMX1JFR0VYIiwiRklYRURfUkVHRVgiLCJwYXJzZURlY2ltYWxUeXBlIiwibWF0Y2giLCJwcmVjaXNpb24iLCJwYXJzZUludCIsInNjYWxlIiwicGFyc2VGaXhlZFR5cGUiLCJsZW5ndGgiLCJpc0RlY2ltYWxUeXBlIiwidGVzdCIsImlzRml4ZWRUeXBlIiwidHlwZXNFcXVhbCIsImEiLCJiIiwiZGVjaW1hbEEiLCJkZWNpbWFsQiIsImZpeGVkQSIsImZpeGVkQiIsImdldEN1cnJlbnRTY2hlbWEiLCJzY2hlbWFzIiwiZmluZCIsInMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/iceberg-js/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/iceberg-js/dist/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/iceberg-js/dist/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IcebergError: () => (/* binding */ IcebergError),\n/* harmony export */   IcebergRestCatalog: () => (/* binding */ IcebergRestCatalog),\n/* harmony export */   getCurrentSchema: () => (/* binding */ getCurrentSchema),\n/* harmony export */   isDecimalType: () => (/* binding */ isDecimalType),\n/* harmony export */   isFixedType: () => (/* binding */ isFixedType),\n/* harmony export */   parseDecimalType: () => (/* binding */ parseDecimalType),\n/* harmony export */   parseFixedType: () => (/* binding */ parseFixedType),\n/* harmony export */   typesEqual: () => (/* binding */ typesEqual)\n/* harmony export */ });\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n    constructor(message, opts){\n        super(message);\n        this.name = \"IcebergError\";\n        this.status = opts.status;\n        this.icebergType = opts.icebergType;\n        this.icebergCode = opts.icebergCode;\n        this.details = opts.details;\n        this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [\n            500,\n            502,\n            504\n        ].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\n    }\n    /**\n   * Returns true if the error is a 404 Not Found error.\n   */ isNotFound() {\n        return this.status === 404;\n    }\n    /**\n   * Returns true if the error is a 409 Conflict error.\n   */ isConflict() {\n        return this.status === 409;\n    }\n    /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */ isAuthenticationTimeout() {\n        return this.status === 419;\n    }\n};\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n    const url = new URL(path, baseUrl);\n    if (query) {\n        for (const [key, value] of Object.entries(query)){\n            if (value !== void 0) {\n                url.searchParams.set(key, value);\n            }\n        }\n    }\n    return url.toString();\n}\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n    if (!auth || auth.type === \"none\") {\n        return {};\n    }\n    if (auth.type === \"bearer\") {\n        return {\n            Authorization: `Bearer ${auth.token}`\n        };\n    }\n    if (auth.type === \"header\") {\n        return {\n            [auth.name]: auth.value\n        };\n    }\n    if (auth.type === \"custom\") {\n        return await auth.getHeaders();\n    }\n    return {};\n}\nfunction createFetchClient(options) {\n    const fetchFn = options.fetchImpl ?? globalThis.fetch;\n    return {\n        async request ({ method, path, query, body, headers }) {\n            const url = buildUrl(options.baseUrl, path, query);\n            const authHeaders = await buildAuthHeaders(options.auth);\n            const res = await fetchFn(url, {\n                method,\n                headers: {\n                    ...body ? {\n                        \"Content-Type\": \"application/json\"\n                    } : {},\n                    ...authHeaders,\n                    ...headers\n                },\n                body: body ? JSON.stringify(body) : void 0\n            });\n            const text = await res.text();\n            const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n            const data = isJson && text ? JSON.parse(text) : text;\n            if (!res.ok) {\n                const errBody = isJson ? data : void 0;\n                const errorDetail = errBody?.error;\n                throw new IcebergError(errorDetail?.message ?? `Request failed with status ${res.status}`, {\n                    status: res.status,\n                    icebergType: errorDetail?.type,\n                    icebergCode: errorDetail?.code,\n                    details: errBody\n                });\n            }\n            return {\n                status: res.status,\n                headers: res.headers,\n                data\n            };\n        }\n    };\n}\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar NamespaceOperations = class {\n    constructor(client, prefix = \"\"){\n        this.client = client;\n        this.prefix = prefix;\n    }\n    async listNamespaces(parent) {\n        const query = parent ? {\n            parent: namespaceToPath(parent.namespace)\n        } : void 0;\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces`,\n            query\n        });\n        return response.data.namespaces.map((ns)=>({\n                namespace: ns\n            }));\n    }\n    async createNamespace(id, metadata) {\n        const request = {\n            namespace: id.namespace,\n            properties: metadata?.properties\n        };\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces`,\n            body: request\n        });\n        return response.data;\n    }\n    async dropNamespace(id) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n    }\n    async loadNamespaceMetadata(id) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n        return {\n            properties: response.data.properties\n        };\n    }\n    async namespaceExists(id) {\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createNamespaceIfNotExists(id, metadata) {\n        try {\n            return await this.createNamespace(id, metadata);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return;\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar TableOperations = class {\n    constructor(client, prefix = \"\", accessDelegation){\n        this.client = client;\n        this.prefix = prefix;\n        this.accessDelegation = accessDelegation;\n    }\n    async listTables(namespace) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\n        });\n        return response.data.identifiers;\n    }\n    async createTable(namespace, request) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\n            body: request,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async updateTable(id, request) {\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            body: request\n        });\n        return {\n            \"metadata-location\": response.data[\"metadata-location\"],\n            metadata: response.data.metadata\n        };\n    }\n    async dropTable(id, options) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            query: {\n                purgeRequested: String(options?.purge ?? false)\n            }\n        });\n    }\n    async loadTable(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async tableExists(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n                headers\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createTableIfNotExists(namespace, request) {\n        try {\n            return await this.createTable(namespace, request);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return await this.loadTable({\n                    namespace: namespace.namespace,\n                    name: request.name\n                });\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n    /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */ constructor(options){\n        let prefix = \"v1\";\n        if (options.catalogName) {\n            prefix += `/${options.catalogName}`;\n        }\n        const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\n        this.client = createFetchClient({\n            baseUrl,\n            auth: options.auth,\n            fetchImpl: options.fetch\n        });\n        this.accessDelegation = options.accessDelegation?.join(\",\");\n        this.namespaceOps = new NamespaceOperations(this.client, prefix);\n        this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n    }\n    /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */ async listNamespaces(parent) {\n        return this.namespaceOps.listNamespaces(parent);\n    }\n    /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */ async createNamespace(id, metadata) {\n        return this.namespaceOps.createNamespace(id, metadata);\n    }\n    /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */ async dropNamespace(id) {\n        await this.namespaceOps.dropNamespace(id);\n    }\n    /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */ async loadNamespaceMetadata(id) {\n        return this.namespaceOps.loadNamespaceMetadata(id);\n    }\n    /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */ async listTables(namespace) {\n        return this.tableOps.listTables(namespace);\n    }\n    /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTable(namespace, request) {\n        return this.tableOps.createTable(namespace, request);\n    }\n    /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */ async updateTable(id, request) {\n        return this.tableOps.updateTable(id, request);\n    }\n    /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */ async dropTable(id, options) {\n        await this.tableOps.dropTable(id, options);\n    }\n    /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */ async loadTable(id) {\n        return this.tableOps.loadTable(id);\n    }\n    /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */ async namespaceExists(id) {\n        return this.namespaceOps.namespaceExists(id);\n    }\n    /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */ async tableExists(id) {\n        return this.tableOps.tableExists(id);\n    }\n    /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */ async createNamespaceIfNotExists(id, metadata) {\n        return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n    }\n    /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTableIfNotExists(namespace, request) {\n        return this.tableOps.createTableIfNotExists(namespace, request);\n    }\n};\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n    const match = type.match(DECIMAL_REGEX);\n    if (!match) return null;\n    return {\n        precision: parseInt(match[1], 10),\n        scale: parseInt(match[2], 10)\n    };\n}\nfunction parseFixedType(type) {\n    const match = type.match(FIXED_REGEX);\n    if (!match) return null;\n    return {\n        length: parseInt(match[1], 10)\n    };\n}\nfunction isDecimalType(type) {\n    return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n    return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n    const decimalA = parseDecimalType(a);\n    const decimalB = parseDecimalType(b);\n    if (decimalA && decimalB) {\n        return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n    }\n    const fixedA = parseFixedType(a);\n    const fixedB = parseFixedType(b);\n    if (fixedA && fixedB) {\n        return fixedA.length === fixedB.length;\n    }\n    return a === b;\n}\nfunction getCurrentSchema(metadata) {\n    return metadata.schemas.find((s)=>s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\n //# sourceMappingURL=index.mjs.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLDZCQUE2QjtBQUM3QixJQUFJQSxlQUFlLGNBQWNDO0lBQy9CQyxZQUFZQyxPQUFPLEVBQUVDLElBQUksQ0FBRTtRQUN6QixLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBR0YsS0FBS0UsTUFBTTtRQUN6QixJQUFJLENBQUNDLFdBQVcsR0FBR0gsS0FBS0csV0FBVztRQUNuQyxJQUFJLENBQUNDLFdBQVcsR0FBR0osS0FBS0ksV0FBVztRQUNuQyxJQUFJLENBQUNDLE9BQU8sR0FBR0wsS0FBS0ssT0FBTztRQUMzQixJQUFJLENBQUNDLG9CQUFvQixHQUFHTixLQUFLRyxXQUFXLEtBQUssaUNBQWlDO1lBQUM7WUFBSztZQUFLO1NBQUksQ0FBQ0ksUUFBUSxDQUFDUCxLQUFLRSxNQUFNLEtBQUtGLEtBQUtHLFdBQVcsRUFBRUksU0FBUyxtQkFBbUI7SUFDM0s7SUFDQTs7R0FFQyxHQUNEQyxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNOLE1BQU0sS0FBSztJQUN6QjtJQUNBOztHQUVDLEdBQ0RPLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQ1AsTUFBTSxLQUFLO0lBQ3pCO0lBQ0E7O0dBRUMsR0FDRFEsMEJBQTBCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDUixNQUFNLEtBQUs7SUFDekI7QUFDRjtBQUVBLG1CQUFtQjtBQUNuQixTQUFTUyxTQUFTQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsS0FBSztJQUNwQyxNQUFNQyxNQUFNLElBQUlDLElBQUlILE1BQU1EO0lBQzFCLElBQUlFLE9BQU87UUFDVCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNOLE9BQVE7WUFDaEQsSUFBSUksVUFBVSxLQUFLLEdBQUc7Z0JBQ3BCSCxJQUFJTSxZQUFZ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O0lBQzFCLE1BQU1zRSxRQUFRdEUsS0FBS3NFLEtBQUssQ0FBQ0Y7SUFDekIsSUFBSSxDQUFDRSxPQUFPLE9BQU87SUFDbkIsT0FBTztRQUNMSyxRQUFRSCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTTSxjQUFjNUUsSUFBSTtJQUN6QixPQUFPbUUsY0FBY1UsSUFBSSxDQUFDN0U7QUFDNUI7QUFDQSxTQUFTOEUsWUFBWTlFLElBQUk7SUFDdkIsT0FBT29FLFlBQVlTLElBQUksQ0FBQzdFO0FBQzFCO0FBQ0EsU0FBUytFLFdBQVdDLENBQUMsRUFBRUMsQ0FBQztJQUN0QixNQUFNQyxXQUFXYixpQkFBaUJXO0lBQ2xDLE1BQU1HLFdBQVdkLGlCQUFpQlk7SUFDbEMsSUFBSUMsWUFBWUMsVUFBVTtRQUN4QixPQUFPRCxTQUFTWCxTQUFTLEtBQUtZLFNBQVNaLFNBQVMsSUFBSVcsU0FBU1QsS0FBSyxLQUFLVSxTQUFTVixLQUFLO0lBQ3ZGO0lBQ0EsTUFBTVcsU0FBU1YsZUFBZU07SUFDOUIsTUFBTUssU0FBU1gsZUFBZU87SUFDOUIsSUFBSUcsVUFBVUMsUUFBUTtRQUNwQixPQUFPRCxPQUFPVCxNQUFNLEtBQUtVLE9BQU9WLE1BQU07SUFDeEM7SUFDQSxPQUFPSyxNQUFNQztBQUNmO0FBQ0EsU0FBU0ssaUJBQWlCNUMsUUFBUTtJQUNoQyxPQUFPQSxTQUFTNkMsT0FBTyxDQUFDQyxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsQ0FBQyxDQUFDLFlBQVksS0FBSy9DLFFBQVEsQ0FBQyxvQkFBb0I7QUFDdEY7QUFFd0ksQ0FDeEksa0NBQWtDO0NBQ2xDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Jlc3RhdXJhbnQtbWVudS1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9kaXN0L2luZGV4Lm1qcz9mY2FlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMvSWNlYmVyZ0Vycm9yLnRzXG52YXIgSWNlYmVyZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkljZWJlcmdFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0cy5zdGF0dXM7XG4gICAgdGhpcy5pY2ViZXJnVHlwZSA9IG9wdHMuaWNlYmVyZ1R5cGU7XG4gICAgdGhpcy5pY2ViZXJnQ29kZSA9IG9wdHMuaWNlYmVyZ0NvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gb3B0cy5kZXRhaWxzO1xuICAgIHRoaXMuaXNDb21taXRTdGF0ZVVua25vd24gPSBvcHRzLmljZWJlcmdUeXBlID09PSBcIkNvbW1pdFN0YXRlVW5rbm93bkV4Y2VwdGlvblwiIHx8IFs1MDAsIDUwMiwgNTA0XS5pbmNsdWRlcyhvcHRzLnN0YXR1cykgJiYgb3B0cy5pY2ViZXJnVHlwZT8uaW5jbHVkZXMoXCJDb21taXRTdGF0ZVwiKSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIDQwNCBOb3QgRm91bmQgZXJyb3IuXG4gICAqL1xuICBpc05vdEZvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gNDA0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDA5IENvbmZsaWN0IGVycm9yLlxuICAgKi9cbiAgaXNDb25mbGljdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDQwOTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIDQxOSBBdXRoZW50aWNhdGlvbiBUaW1lb3V0IGVycm9yLlxuICAgKi9cbiAgaXNBdXRoZW50aWNhdGlvblRpbWVvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSA0MTk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy91cmwudHNcbmZ1bmN0aW9uIGJ1aWxkVXJsKGJhc2VVcmwsIHBhdGgsIHF1ZXJ5KSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocGF0aCwgYmFzZVVybCk7XG4gIGlmIChxdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuLy8gc3JjL2h0dHAvY3JlYXRlRmV0Y2hDbGllbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkQXV0aEhlYWRlcnMoYXV0aCkge1xuICBpZiAoIWF1dGggfHwgYXV0aC50eXBlID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoYXV0aC50eXBlID09PSBcImJlYXJlclwiKSB7XG4gICAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGgudG9rZW59YCB9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiaGVhZGVyXCIpIHtcbiAgICByZXR1cm4geyBbYXV0aC5uYW1lXTogYXV0aC52YWx1ZSB9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICByZXR1cm4gYXdhaXQgYXV0aC5nZXRIZWFkZXJzKCk7XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDbGllbnQob3B0aW9ucykge1xuICBjb25zdCBmZXRjaEZuID0gb3B0aW9ucy5mZXRjaEltcGwgPz8gZ2xvYmFsVGhpcy5mZXRjaDtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyByZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhdGgsXG4gICAgICBxdWVyeSxcbiAgICAgIGJvZHksXG4gICAgICBoZWFkZXJzXG4gICAgfSkge1xuICAgICAgY29uc3QgdXJsID0gYnVpbGRVcmwob3B0aW9ucy5iYXNlVXJsLCBwYXRoLCBxdWVyeSk7XG4gICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IGJ1aWxkQXV0aEhlYWRlcnMob3B0aW9ucy5hdXRoKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoRm4odXJsLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmJvZHkgPyB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0gOiB7fSxcbiAgICAgICAgICAuLi5hdXRoSGVhZGVycyxcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIGNvbnN0IGlzSnNvbiA9IChyZXMuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIikuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgY29uc3QgZGF0YSA9IGlzSnNvbiAmJiB0ZXh0ID8gSlNPTi5wYXJzZSh0ZXh0KSA6IHRleHQ7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJCb2R5ID0gaXNKc29uID8gZGF0YSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZXJyb3JEZXRhaWwgPSBlcnJCb2R5Py5lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IEljZWJlcmdFcnJvcihcbiAgICAgICAgICBlcnJvckRldGFpbD8ubWVzc2FnZSA/PyBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXMuc3RhdHVzfWAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgaWNlYmVyZ1R5cGU6IGVycm9yRGV0YWlsPy50eXBlLFxuICAgICAgICAgICAgaWNlYmVyZ0NvZGU6IGVycm9yRGV0YWlsPy5jb2RlLFxuICAgICAgICAgICAgZGV0YWlsczogZXJyQm9keVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogcmVzLnN0YXR1cywgaGVhZGVyczogcmVzLmhlYWRlcnMsIGRhdGEgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9jYXRhbG9nL25hbWVzcGFjZXMudHNcbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aChuYW1lc3BhY2UpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZS5qb2luKFwiXHUwMDFmXCIpO1xufVxudmFyIE5hbWVzcGFjZU9wZXJhdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcHJlZml4ID0gXCJcIikge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICB9XG4gIGFzeW5jIGxpc3ROYW1lc3BhY2VzKHBhcmVudCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gcGFyZW50ID8geyBwYXJlbnQ6IG5hbWVzcGFjZVRvUGF0aChwYXJlbnQubmFtZXNwYWNlKSB9IDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlc2AsXG4gICAgICBxdWVyeVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm5hbWVzcGFjZXMubWFwKChucykgPT4gKHsgbmFtZXNwYWNlOiBucyB9KSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBuYW1lc3BhY2U6IGlkLm5hbWVzcGFjZSxcbiAgICAgIHByb3BlcnRpZXM6IG1ldGFkYXRhPy5wcm9wZXJ0aWVzXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzYCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBkcm9wTmFtZXNwYWNlKGlkKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICB9KTtcbiAgfVxuICBhc3luYyBsb2FkTmFtZXNwYWNlTWV0YWRhdGEoaWQpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgoaWQubmFtZXNwYWNlKX1gXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BlcnRpZXM6IHJlc3BvbnNlLmRhdGEucHJvcGVydGllc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgbmFtZXNwYWNlRXhpc3RzKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiLFxuICAgICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2F0YWxvZy90YWJsZXMudHNcbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlKSB7XG4gIHJldHVybiBuYW1lc3BhY2Uuam9pbihcIlx1MDAxZlwiKTtcbn1cbnZhciBUYWJsZU9wZXJhdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcHJlZml4ID0gXCJcIiwgYWNjZXNzRGVsZWdhdGlvbikge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYWNjZXNzRGVsZWdhdGlvbiA9IGFjY2Vzc0RlbGVnYXRpb247XG4gIH1cbiAgYXN5bmMgbGlzdFRhYmxlcyhuYW1lc3BhY2UpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKG5hbWVzcGFjZS5uYW1lc3BhY2UpfS90YWJsZXNgXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuaWRlbnRpZmllcnM7XG4gIH1cbiAgYXN5bmMgY3JlYXRlVGFibGUobmFtZXNwYWNlLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKG5hbWVzcGFjZS5uYW1lc3BhY2UpfS90YWJsZXNgLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXRhZGF0YTtcbiAgfVxuICBhc3luYyB1cGRhdGVUYWJsZShpZCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgXCJtZXRhZGF0YS1sb2NhdGlvblwiOiByZXNwb25zZS5kYXRhW1wibWV0YWRhdGEtbG9jYXRpb25cIl0sXG4gICAgICBtZXRhZGF0YTogcmVzcG9uc2UuZGF0YS5tZXRhZGF0YVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZHJvcFRhYmxlKGlkLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgcXVlcnk6IHsgcHVyZ2VSZXF1ZXN0ZWQ6IFN0cmluZyhvcHRpb25zPy5wdXJnZSA/PyBmYWxzZSkgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGxvYWRUYWJsZShpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgICBoZWFkZXJzW1wiWC1JY2ViZXJnLUFjY2Vzcy1EZWxlZ2F0aW9uXCJdID0gdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXRhZGF0YTtcbiAgfVxuICBhc3luYyB0YWJsZUV4aXN0cyhpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgICBoZWFkZXJzW1wiWC1JY2ViZXJnLUFjY2Vzcy1EZWxlZ2F0aW9uXCJdID0gdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCIsXG4gICAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlVGFibGUobmFtZXNwYWNlLCByZXF1ZXN0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvYWRUYWJsZSh7IG5hbWVzcGFjZTogbmFtZXNwYWNlLm5hbWVzcGFjZSwgbmFtZTogcmVxdWVzdC5uYW1lIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2F0YWxvZy9JY2ViZXJnUmVzdENhdGFsb2cudHNcbnZhciBJY2ViZXJnUmVzdENhdGFsb2cgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjYXRhbG9nIGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGxldCBwcmVmaXggPSBcInYxXCI7XG4gICAgaWYgKG9wdGlvbnMuY2F0YWxvZ05hbWUpIHtcbiAgICAgIHByZWZpeCArPSBgLyR7b3B0aW9ucy5jYXRhbG9nTmFtZX1gO1xuICAgIH1cbiAgICBjb25zdCBiYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJsLmVuZHNXaXRoKFwiL1wiKSA/IG9wdGlvbnMuYmFzZVVybCA6IGAke29wdGlvbnMuYmFzZVVybH0vYDtcbiAgICB0aGlzLmNsaWVudCA9IGNyZWF0ZUZldGNoQ2xpZW50KHtcbiAgICAgIGJhc2VVcmwsXG4gICAgICBhdXRoOiBvcHRpb25zLmF1dGgsXG4gICAgICBmZXRjaEltcGw6IG9wdGlvbnMuZmV0Y2hcbiAgICB9KTtcbiAgICB0aGlzLmFjY2Vzc0RlbGVnYXRpb24gPSBvcHRpb25zLmFjY2Vzc0RlbGVnYXRpb24/LmpvaW4oXCIsXCIpO1xuICAgIHRoaXMubmFtZXNwYWNlT3BzID0gbmV3IE5hbWVzcGFjZU9wZXJhdGlvbnModGhpcy5jbGllbnQsIHByZWZpeCk7XG4gICAgdGhpcy50YWJsZU9wcyA9IG5ldyBUYWJsZU9wZXJhdGlvbnModGhpcy5jbGllbnQsIHByZWZpeCwgdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIG5hbWVzcGFjZXMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnQgLSBPcHRpb25hbCBwYXJlbnQgbmFtZXNwYWNlIHRvIGxpc3QgY2hpbGRyZW4gdW5kZXJcbiAgICogQHJldHVybnMgQXJyYXkgb2YgbmFtZXNwYWNlIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogLy8gTGlzdCBhbGwgdG9wLWxldmVsIG5hbWVzcGFjZXNcbiAgICogY29uc3QgbmFtZXNwYWNlcyA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKTtcbiAgICpcbiAgICogLy8gTGlzdCBuYW1lc3BhY2VzIHVuZGVyIGEgcGFyZW50XG4gICAqIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsaXN0TmFtZXNwYWNlcyhwYXJlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMubGlzdE5hbWVzcGFjZXMocGFyZW50KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBuYW1lc3BhY2UgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBPcHRpb25hbCBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIFJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGNyZWF0ZWQgbmFtZXNwYWNlIGFuZCBpdHMgcHJvcGVydGllc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2UoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nIH0gfVxuICAgKiApO1xuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5uYW1lc3BhY2UpOyAvLyBbJ2FuYWx5dGljcyddXG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLnByb3BlcnRpZXMpOyAvLyB7IG93bmVyOiAnZGF0YS10ZWFtJywgLi4uIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVOYW1lc3BhY2UoaWQsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBhIG5hbWVzcGFjZSBmcm9tIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBUaGUgbmFtZXNwYWNlIG11c3QgYmUgZW1wdHkgKGNvbnRhaW4gbm8gdGFibGVzKSBiZWZvcmUgaXQgY2FuIGJlIGRyb3BwZWQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGRyb3BcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBhd2FpdCBjYXRhbG9nLmRyb3BOYW1lc3BhY2UoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZHJvcE5hbWVzcGFjZShpZCkge1xuICAgIGF3YWl0IHRoaXMubmFtZXNwYWNlT3BzLmRyb3BOYW1lc3BhY2UoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBtZXRhZGF0YSBmb3IgYSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGxvYWRcbiAgICogQHJldHVybnMgTmFtZXNwYWNlIG1ldGFkYXRhIGluY2x1ZGluZyBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmxvYWROYW1lc3BhY2VNZXRhZGF0YSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEucHJvcGVydGllcyk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbG9hZE5hbWVzcGFjZU1ldGFkYXRhKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmxvYWROYW1lc3BhY2VNZXRhZGF0YShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIGFsbCB0YWJsZXMgaW4gYSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBsaXN0IHRhYmxlcyBmcm9tXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHRhYmxlIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgdGFibGVzID0gYXdhaXQgY2F0YWxvZy5saXN0VGFibGVzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyh0YWJsZXMpOyAvLyBbeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0sIC4uLl1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsaXN0VGFibGVzKG5hbWVzcGFjZSkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmxpc3RUYWJsZXMobmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0YWJsZSBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE5hbWVzcGFjZSB0byBjcmVhdGUgdGhlIHRhYmxlIGluXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGFibGUgY3JlYXRpb24gcmVxdWVzdCBpbmNsdWRpbmcgbmFtZSwgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgZXRjLlxuICAgKiBAcmV0dXJucyBUYWJsZSBtZXRhZGF0YSBmb3IgdGhlIGNyZWF0ZWQgdGFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlVGFibGUoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7XG4gICAqICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICogICAgICAgZmllbGRzOiBbXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfVxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMFxuICAgKiAgICAgfSxcbiAgICogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcbiAgICogICAgICAgJ3NwZWMtaWQnOiAwLFxuICAgKiAgICAgICBmaWVsZHM6IFtcbiAgICogICAgICAgICB7IHNvdXJjZV9pZDogMiwgZmllbGRfaWQ6IDEwMDAsIG5hbWU6ICd0c19kYXknLCB0cmFuc2Zvcm06ICdkYXknIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5jcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIHRhYmxlJ3MgbWV0YWRhdGEuXG4gICAqXG4gICAqIENhbiB1cGRhdGUgdGhlIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIG9yIHByb3BlcnRpZXMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byB1cGRhdGVcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBVcGRhdGUgcmVxdWVzdCB3aXRoIGZpZWxkcyB0byBtb2RpZnlcbiAgICogQHJldHVybnMgUmVzcG9uc2UgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgbG9jYXRpb24gYW5kIHVwZGF0ZWQgdGFibGUgbWV0YWRhdGFcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhdGFsb2cudXBkYXRlVGFibGUoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0sXG4gICAqICAge1xuICAgKiAgICAgcHJvcGVydGllczogeyAncmVhZC5zcGxpdC50YXJnZXQtc2l6ZSc6ICcxMzQyMTc3MjgnIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlWydtZXRhZGF0YS1sb2NhdGlvbiddKTsgLy8gczM6Ly8uLi5cbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UubWV0YWRhdGEpOyAvLyBUYWJsZU1ldGFkYXRhIG9iamVjdFxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMudXBkYXRlVGFibGUoaWQsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBhIHRhYmxlIGZyb20gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gZHJvcFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBkcm9wVGFibGUoaWQsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLnRhYmxlT3BzLmRyb3BUYWJsZShpZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIG1ldGFkYXRhIGZvciBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIGxvYWRcbiAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgaW5jbHVkaW5nIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIGxvY2F0aW9uLCBldGMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmxvYWRUYWJsZSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSk7XG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLnNjaGVtYSk7XG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLmxvY2F0aW9uKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2FkVGFibGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5sb2FkVGFibGUoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBuYW1lc3BhY2UgZXhpc3RzIGluIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBuYW1lc3BhY2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBleGlzdHMgPSBhd2FpdCBjYXRhbG9nLm5hbWVzcGFjZUV4aXN0cyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogY29uc29sZS5sb2coZXhpc3RzKTsgLy8gdHJ1ZSBvciBmYWxzZVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIG5hbWVzcGFjZUV4aXN0cyhpZCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5uYW1lc3BhY2VFeGlzdHMoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSB0YWJsZSBleGlzdHMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gY2hlY2tcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdGFibGUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBleGlzdHMgPSBhd2FpdCBjYXRhbG9nLnRhYmxlRXhpc3RzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogY29uc29sZS5sb2coZXhpc3RzKTsgLy8gdHJ1ZSBvciBmYWxzZVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRhYmxlRXhpc3RzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMudGFibGVFeGlzdHMoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmFtZXNwYWNlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBJZiB0aGUgbmFtZXNwYWNlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIHZvaWQuIElmIGNyZWF0ZWQsIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBjcmVhdGVcbiAgICogQHBhcmFtIG1ldGFkYXRhIC0gT3B0aW9uYWwgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgdGhlIG5hbWVzcGFjZVxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBjcmVhdGVkIG5hbWVzcGFjZSBhbmQgaXRzIHByb3BlcnRpZXMsIG9yIHZvaWQgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nIH0gfVxuICAgKiApO1xuICAgKiBpZiAocmVzcG9uc2UpIHtcbiAgICogICBjb25zb2xlLmxvZygnQ3JlYXRlZDonLCByZXNwb25zZS5uYW1lc3BhY2UpO1xuICAgKiB9IGVsc2Uge1xuICAgKiAgIGNvbnNvbGUubG9nKCdBbHJlYWR5IGV4aXN0cycpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmNyZWF0ZU5hbWVzcGFjZUlmTm90RXhpc3RzKGlkLCBtZXRhZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0YWJsZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogSWYgdGhlIHRhYmxlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIGl0cyBtZXRhZGF0YSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIHRvIGNyZWF0ZSB0aGUgdGFibGUgaW5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUYWJsZSBjcmVhdGlvbiByZXF1ZXN0IGluY2x1ZGluZyBuYW1lLCBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBldGMuXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGZvciB0aGUgY3JlYXRlZCBvciBleGlzdGluZyB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZUlmTm90RXhpc3RzKFxuICAgKiAgIHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0sXG4gICAqICAge1xuICAgKiAgICAgbmFtZTogJ2V2ZW50cycsXG4gICAqICAgICBzY2hlbWE6IHtcbiAgICogICAgICAgdHlwZTogJ3N0cnVjdCcsXG4gICAqICAgICAgIGZpZWxkczogW1xuICAgKiAgICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdpZCcsIHR5cGU6ICdsb25nJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH1cbiAgICogICAgICAgXSxcbiAgICogICAgICAgJ3NjaGVtYS1pZCc6IDBcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5jcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL3R5cGVzLnRzXG52YXIgREVDSU1BTF9SRUdFWCA9IC9eZGVjaW1hbFxccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKSQvO1xudmFyIEZJWEVEX1JFR0VYID0gL15maXhlZFxccypcXFtcXHMqKFxcZCspXFxzKlxcXSQvO1xuZnVuY3Rpb24gcGFyc2VEZWNpbWFsVHlwZSh0eXBlKSB7XG4gIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChERUNJTUFMX1JFR0VYKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgcHJlY2lzaW9uOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxuICAgIHNjYWxlOiBwYXJzZUludChtYXRjaFsyXSwgMTApXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUZpeGVkVHlwZSh0eXBlKSB7XG4gIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChGSVhFRF9SRUdFWCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIGxlbmd0aDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKVxuICB9O1xufVxuZnVuY3Rpb24gaXNEZWNpbWFsVHlwZSh0eXBlKSB7XG4gIHJldHVybiBERUNJTUFMX1JFR0VYLnRlc3QodHlwZSk7XG59XG5mdW5jdGlvbiBpc0ZpeGVkVHlwZSh0eXBlKSB7XG4gIHJldHVybiBGSVhFRF9SRUdFWC50ZXN0KHR5cGUpO1xufVxuZnVuY3Rpb24gdHlwZXNFcXVhbChhLCBiKSB7XG4gIGNvbnN0IGRlY2ltYWxBID0gcGFyc2VEZWNpbWFsVHlwZShhKTtcbiAgY29uc3QgZGVjaW1hbEIgPSBwYXJzZURlY2ltYWxUeXBlKGIpO1xuICBpZiAoZGVjaW1hbEEgJiYgZGVjaW1hbEIpIHtcbiAgICByZXR1cm4gZGVjaW1hbEEucHJlY2lzaW9uID09PSBkZWNpbWFsQi5wcmVjaXNpb24gJiYgZGVjaW1hbEEuc2NhbGUgPT09IGRlY2ltYWxCLnNjYWxlO1xuICB9XG4gIGNvbnN0IGZpeGVkQSA9IHBhcnNlRml4ZWRUeXBlKGEpO1xuICBjb25zdCBmaXhlZEIgPSBwYXJzZUZpeGVkVHlwZShiKTtcbiAgaWYgKGZpeGVkQSAmJiBmaXhlZEIpIHtcbiAgICByZXR1cm4gZml4ZWRBLmxlbmd0aCA9PT0gZml4ZWRCLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY2hlbWEobWV0YWRhdGEpIHtcbiAgcmV0dXJuIG1ldGFkYXRhLnNjaGVtYXMuZmluZCgocykgPT4gc1tcInNjaGVtYS1pZFwiXSA9PT0gbWV0YWRhdGFbXCJjdXJyZW50LXNjaGVtYS1pZFwiXSk7XG59XG5cbmV4cG9ydCB7IEljZWJlcmdFcnJvciwgSWNlYmVyZ1Jlc3RDYXRhbG9nLCBnZXRDdXJyZW50U2NoZW1hLCBpc0RlY2ltYWxUeXBlLCBpc0ZpeGVkVHlwZSwgcGFyc2VEZWNpbWFsVHlwZSwgcGFyc2VGaXhlZFR5cGUsIHR5cGVzRXF1YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiSWNlYmVyZ0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcHRzIiwibmFtZSIsInN0YXR1cyIsImljZWJlcmdUeXBlIiwiaWNlYmVyZ0NvZGUiLCJkZXRhaWxzIiwiaXNDb21taXRTdGF0ZVVua25vd24iLCJpbmNsdWRlcyIsImlzTm90Rm91bmQiLCJpc0NvbmZsaWN0IiwiaXNBdXRoZW50aWNhdGlvblRpbWVvdXQiLCJidWlsZFVybCIsImJhc2VVcmwiLCJwYXRoIiwicXVlcnkiLCJ1cmwiLCJVUkwiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJ0b1N0cmluZyIsImJ1aWxkQXV0aEhlYWRlcnMiLCJhdXRoIiwidHlwZSIsIkF1dGhvcml6YXRpb24iLCJ0b2tlbiIsImdldEhlYWRlcnMiLCJjcmVhdGVGZXRjaENsaWVudCIsIm9wdGlvbnMiLCJmZXRjaEZuIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwicmVxdWVzdCIsIm1ldGhvZCIsImJvZHkiLCJoZWFkZXJzIiwiYXV0aEhlYWRlcnMiLCJyZXMiLCJKU09OIiwic3RyaW5naWZ5IiwidGV4dCIsImlzSnNvbiIsImdldCIsImRhdGEiLCJwYXJzZSIsIm9rIiwiZXJyQm9keSIsImVycm9yRGV0YWlsIiwiZXJyb3IiLCJjb2RlIiwibmFtZXNwYWNlVG9QYXRoIiwibmFtZXNwYWNlIiwiam9pbiIsIk5hbWVzcGFjZU9wZXJhdGlvbnMiLCJjbGllbnQiLCJwcmVmaXgiLCJsaXN0TmFtZXNwYWNlcyIsInBhcmVudCIsInJlc3BvbnNlIiwibmFtZXNwYWNlcyIsIm1hcCIsIm5zIiwiY3JlYXRlTmFtZXNwYWNlIiwiaWQiLCJtZXRhZGF0YSIsInByb3BlcnRpZXMiLCJkcm9wTmFtZXNwYWNlIiwibG9hZE5hbWVzcGFjZU1ldGFkYXRhIiwibmFtZXNwYWNlRXhpc3RzIiwiY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMiLCJuYW1lc3BhY2VUb1BhdGgyIiwiVGFibGVPcGVyYXRpb25zIiwiYWNjZXNzRGVsZWdhdGlvbiIsImxpc3RUYWJsZXMiLCJpZGVudGlmaWVycyIsImNyZWF0ZVRhYmxlIiwidXBkYXRlVGFibGUiLCJkcm9wVGFibGUiLCJwdXJnZVJlcXVlc3RlZCIsIlN0cmluZyIsInB1cmdlIiwibG9hZFRhYmxlIiwidGFibGVFeGlzdHMiLCJjcmVhdGVUYWJsZUlmTm90RXhpc3RzIiwiSWNlYmVyZ1Jlc3RDYXRhbG9nIiwiY2F0YWxvZ05hbWUiLCJlbmRzV2l0aCIsIm5hbWVzcGFjZU9wcyIsInRhYmxlT3BzIiwiREVDSU1BTF9SRUdFWCIsIkZJWEVEX1JFR0VYIiwicGFyc2VEZWNpbWFsVHlwZSIsIm1hdGNoIiwicHJlY2lzaW9uIiwicGFyc2VJbnQiLCJzY2FsZSIsInBhcnNlRml4ZWRUeXBlIiwibGVuZ3RoIiwiaXNEZWNpbWFsVHlwZSIsInRlc3QiLCJpc0ZpeGVkVHlwZSIsInR5cGVzRXF1YWwiLCJhIiwiYiIsImRlY2ltYWxBIiwiZGVjaW1hbEIiLCJmaXhlZEEiLCJmaXhlZEIiLCJnZXRDdXJyZW50U2NoZW1hIiwic2NoZW1hcyIsImZpbmQiLCJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/iceberg-js/dist/index.mjs\n");

/***/ })

};
;